{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Simple DirectMedia Layer {#mainpage} (SDL) Version 2.0 http://www.libsdl.org/ Simple DirectMedia Layer is a cross-platform development library designed to provide low level access to audio, keyboard, mouse, joystick, and graphics hardware via OpenGL and Direct3D. It is used by video playback software, emulators, and popular games including Valve's award winning catalog and many Humble Bundle games. SDL officially supports Windows, Mac OS X, Linux, iOS, and Android. Support for other platforms may be found in the source code. SDL is written in C, works natively with C++, and there are bindings available for several other languages, including C# and Python. This library is distributed under the zlib license, which can be found in the file \"LICENSE.txt\". The best way to learn how to use SDL is to check out the header files in the \"include\" subdirectory and the programs in the \"test\" subdirectory. The header files and test programs are well commented and always up to date. More documentation and FAQs are available online at the wiki Android CMake DirectFB DynAPI Emscripten Gesture Git iOS Linux OS X Native Client Pandora Supported Platforms Porting information PSP Raspberry Pi Touch WinCE Windows WinRT If you need help with the library, or just want to discuss SDL related issues, you can join the SDL Discourse , which can be used as a web forum or a mailing list, at your preference. If you want to report bugs or contribute patches, please submit them to our bug tracker Enjoy! Sam Lantinga slouken@libsdl.org","title":"Home"},{"location":"#simple-directmedia-layer-mainpage","text":"(SDL) Version 2.0 http://www.libsdl.org/ Simple DirectMedia Layer is a cross-platform development library designed to provide low level access to audio, keyboard, mouse, joystick, and graphics hardware via OpenGL and Direct3D. It is used by video playback software, emulators, and popular games including Valve's award winning catalog and many Humble Bundle games. SDL officially supports Windows, Mac OS X, Linux, iOS, and Android. Support for other platforms may be found in the source code. SDL is written in C, works natively with C++, and there are bindings available for several other languages, including C# and Python. This library is distributed under the zlib license, which can be found in the file \"LICENSE.txt\". The best way to learn how to use SDL is to check out the header files in the \"include\" subdirectory and the programs in the \"test\" subdirectory. The header files and test programs are well commented and always up to date. More documentation and FAQs are available online at the wiki Android CMake DirectFB DynAPI Emscripten Gesture Git iOS Linux OS X Native Client Pandora Supported Platforms Porting information PSP Raspberry Pi Touch WinCE Windows WinRT If you need help with the library, or just want to discuss SDL related issues, you can join the SDL Discourse , which can be used as a web forum or a mailing list, at your preference. If you want to report bugs or contribute patches, please submit them to our bug tracker Enjoy! Sam Lantinga slouken@libsdl.org","title":"Simple DirectMedia Layer {#mainpage}"},{"location":"README-android/","text":"Android Matt Styles wrote a tutorial on building SDL for Android with Visual Studio: http://trederia.blogspot.de/2017/03/building-sdl2-for-android-with-visual.html The rest of this README covers the Android gradle style build process. If you are using the older ant build process, it is no longer officially supported, but you can use the \"android-project-ant\" directory as a template. ================================================================================ Requirements ================================================================================ Android SDK (version 26 or later) https://developer.android.com/sdk/index.html Android NDK r15c or later https://developer.android.com/tools/sdk/ndk/index.html Minimum API level supported by SDL: 16 (Android 4.1) ================================================================================ How the port works ================================================================================ Android applications are Java-based, optionally with parts written in C As SDL apps are C-based, we use a small Java shim that uses JNI to talk to the SDL library This means that your application C code must be placed inside an Android Java project, along with some C support code that communicates with Java This eventually produces a standard Android .apk package The Android Java code implements an \"Activity\" and can be found in: android-project/app/src/main/java/org/libsdl/app/SDLActivity.java The Java code loads your game code, the SDL shared library, and dispatches to native functions implemented in the SDL library: src/core/android/SDL_android.c ================================================================================ Building an app ================================================================================ For simple projects you can use the script located at build-scripts/androidbuild.sh There's two ways of using it: androidbuild.sh com.yourcompany.yourapp < sources.list androidbuild.sh com.yourcompany.yourapp source1.c source2.c ...sourceN.c sources.list should be a text file with a source file name in each line Filenames should be specified relative to the current directory, for example if you are in the build-scripts directory and want to create the testgles.c test, you'll run: ./androidbuild.sh org.libsdl.testgles ../test/testgles.c One limitation of this script is that all sources provided will be aggregated into a single directory, thus all your source files should have a unique name. Once the project is complete the script will tell you where the debug APK is located. If you want to create a signed release APK, you can use the project created by this utility to generate it. Finally, a word of caution: re running androidbuild.sh wipes any changes you may have done in the build directory for the app! For more complex projects, follow these instructions: Copy the android-project directory wherever you want to keep your projects and rename it to the name of your project. Move or symlink this SDL directory into the \" /app/jni\" directory Edit \" /app/jni/src/Android.mk\" to include your source files 4a. If you want to use Android Studio, simply open your directory and start building. 4b. If you want to build manually, run './gradlew installDebug' in the project directory. This compiles the .java, creates an .apk with the native code embedded, and installs it on any connected Android device If you already have a project that uses CMake, the instructions change somewhat: Do points 1 and 2 from the instruction above. Edit \" /app/build.gradle\" to comment out or remove sections containing ndk-build and uncomment the cmake sections. Add arguments to the CMake invocation as needed. Edit \" /app/jni/CMakeLists.txt\" to include your project (it defaults to adding the \"src\" subdirectory). Note that you'll have SDL2, SDL2main and SDL2-static as targets in your project, so you should have \"target_link_libraries(yourgame SDL2 SDL2main)\" in your CMakeLists.txt file. Also be aware that you should use add_library() instead of add_executable() for the target containing your \"main\" function. If you wish to use Android Studio, you can skip the last step. Run './gradlew installDebug' or './gradlew installRelease' in the project directory. It will build and install your .apk on any connected Android device Here's an explanation of the files in the Android project, so you can customize them: android-project/app build.gradle - build info including the application version and SDK src/main/AndroidManifest.xml - package manifest. Among others, it contains the class name of the main Activity and the package name of the application. jni/ - directory holding native code jni/Application.mk - Application JNI settings, including target platform and STL library jni/Android.mk - Android makefile that can call recursively the Android.mk files in all subdirectories jni/CMakeLists.txt - Top-level CMake project that adds SDL as a subproject jni/SDL/ - (symlink to) directory holding the SDL library files jni/SDL/Android.mk - Android makefile for creating the SDL shared library jni/src/ - directory holding your C/C++ source jni/src/Android.mk - Android makefile that you should customize to include your source code and any library references jni/src/CMakeLists.txt - CMake file that you may customize to include your source code and any library references src/main/assets/ - directory holding asset files for your application src/main/res/ - directory holding resources for your application src/main/res/mipmap-* - directories holding icons for different phone hardware src/main/res/values/strings.xml - strings used in your application, including the application name src/main/java/org/libsdl/app/SDLActivity.java - the Java class handling the initialization and binding to SDL. Be very careful changing this, as the SDL library relies on this implementation. You should instead subclass this for your application. ================================================================================ Customizing your application name ================================================================================ To customize your application name, edit AndroidManifest.xml and replace \"org.libsdl.app\" with an identifier for your product package. Then create a Java class extending SDLActivity and place it in a directory under src matching your package, e.g. src/com/gamemaker/game/MyGame.java Here's an example of a minimal class file: --- MyGame.java -------------------------- package com.gamemaker.game; import org.libsdl.app.SDLActivity; /** * A sample wrapper class that just calls SDLActivity */ public class MyGame extends SDLActivity { } ------------------------------------------ Then replace \"SDLActivity\" in AndroidManifest.xml with the name of your class, .e.g. \"MyGame\" ================================================================================ Customizing your application icon ================================================================================ Conceptually changing your icon is just replacing the \"ic_launcher.png\" files in the drawable directories under the res directory. There are several directories for different screen sizes. ================================================================================ Loading assets ================================================================================ Any files you put in the \"app/src/main/assets\" directory of your project directory will get bundled into the application package and you can load them using the standard functions in SDL_rwops.h. There are also a few Android specific functions that allow you to get other useful paths for saving and loading data: * SDL_AndroidGetInternalStoragePath() * SDL_AndroidGetExternalStorageState() * SDL_AndroidGetExternalStoragePath() See SDL_system.h for more details on these functions. The asset packaging system will, by default, compress certain file extensions. SDL includes two asset file access mechanisms, the preferred one is the so called \"File Descriptor\" method, which is faster and doesn't involve the Dalvik GC, but given this method does not work on compressed assets, there is also the \"Input Stream\" method, which is automatically used as a fall back by SDL. You may want to keep this fact in mind when building your APK, specially when large files are involved. For more information on which extensions get compressed by default and how to disable this behaviour, see for example: http://ponystyle.com/blog/2010/03/26/dealing-with-asset-compression-in-android-apps/ ================================================================================ Pause / Resume behaviour ================================================================================ If SDL_HINT_ANDROID_BLOCK_ON_PAUSE hint is set (the default), the event loop will block itself when the app is paused (ie, when the user returns to the main Android dashboard). Blocking is better in terms of battery use, and it allows your app to spring back to life instantaneously after resume (versus polling for a resume message). Upon resume, SDL will attempt to restore the GL context automatically. In modern devices (Android 3.0 and up) this will most likely succeed and your app can continue to operate as it was. However, there's a chance (on older hardware, or on systems under heavy load), where the GL context can not be restored. In that case you have to listen for a specific message (SDL_RENDER_DEVICE_RESET) and restore your textures manually or quit the app. You should not use the SDL renderer API while the app going in background: - SDL_APP_WILLENTERBACKGROUND: after you read this message, GL context gets backed-up and you should not use the SDL renderer API. SDL_APP_DIDENTERFOREGROUND: GL context is restored, and the SDL renderer API is available (unless you receive SDL_RENDER_DEVICE_RESET). ================================================================================ Mouse / Touch events ================================================================================ In some case, SDL generates synthetic mouse (resp. touch) events for touch (resp. mouse) devices. To enable/disable this behavior, see SDL_hints.h: - SDL_HINT_TOUCH_MOUSE_EVENTS - SDL_HINT_MOUSE_TOUCH_EVENTS ================================================================================ Misc ================================================================================ For some device, it appears to works better setting explicitly GL attributes before creating a window: SDL_GL_SetAttribute(SDL_GL_RED_SIZE, 5); SDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, 6); SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, 5); ================================================================================ Threads and the Java VM ================================================================================ For a quick tour on how Linux native threads interoperate with the Java VM, take a look here: https://developer.android.com/guide/practices/jni.html If you want to use threads in your SDL app, it's strongly recommended that you do so by creating them using SDL functions. This way, the required attach/detach handling is managed by SDL automagically. If you have threads created by other means and they make calls to SDL functions, make sure that you call Android_JNI_SetupThread() before doing anything else otherwise SDL will attach your thread automatically anyway (when you make an SDL call), but it'll never detach it. ================================================================================ Using STL ================================================================================ You can use STL in your project by creating an Application.mk file in the jni folder and adding the following line: APP_STL := c++_shared For more information go here: https://developer.android.com/ndk/guides/cpp-support ================================================================================ Using the emulator ================================================================================ There are some good tips and tricks for getting the most out of the emulator here: https://developer.android.com/tools/devices/emulator.html Especially useful is the info on setting up OpenGL ES 2.0 emulation. Notice that this software emulator is incredibly slow and needs a lot of disk space. Using a real device works better. ================================================================================ Troubleshooting ================================================================================ You can see if adb can see any devices with the following command: adb devices You can see the output of log messages on the default device with: adb logcat You can push files to the device with: adb push local_file remote_path_and_file You can push files to the SD Card at /sdcard, for example: adb push moose.dat /sdcard/moose.dat You can see the files on the SD card with a shell command: adb shell ls /sdcard/ You can start a command shell on the default device with: adb shell You can remove the library files of your project (and not the SDL lib files) with: ndk-build clean You can do a build with the following command: ndk-build You can see the complete command line that ndk-build is using by passing V=1 on the command line: ndk-build V=1 If your application crashes in native code, you can use ndk-stack to get a symbolic stack trace: https://developer.android.com/ndk/guides/ndk-stack If you want to go through the process manually, you can use addr2line to convert the addresses in the stack trace to lines in your code. For example, if your crash looks like this: I/DEBUG ( 31): signal 11 (SIGSEGV), code 2 (SEGV_ACCERR), fault addr 400085d0 I/DEBUG ( 31): r0 00000000 r1 00001000 r2 00000003 r3 400085d4 I/DEBUG ( 31): r4 400085d0 r5 40008000 r6 afd41504 r7 436c6a7c I/DEBUG ( 31): r8 436c6b30 r9 435c6fb0 10 435c6f9c fp 4168d82c I/DEBUG ( 31): ip 8346aff0 sp 436c6a60 lr afd1c8ff pc afd1c902 cpsr 60000030 I/DEBUG ( 31): #00 pc 0001c902 /system/lib/libc.so I/DEBUG ( 31): #01 pc 0001ccf6 /system/lib/libc.so I/DEBUG ( 31): #02 pc 000014bc /data/data/org.libsdl.app/lib/libmain.so I/DEBUG ( 31): #03 pc 00001506 /data/data/org.libsdl.app/lib/libmain.so You can see that there's a crash in the C library being called from the main code. I run addr2line with the debug version of my code: arm-eabi-addr2line -C -f -e obj/local/armeabi/libmain.so and then paste in the number after \"pc\" in the call stack, from the line that I care about: 000014bc I get output from addr2line showing that it's in the quit function, in testspriteminimal.c, on line 23. You can add logging to your code to help show what's happening: #include <android/log.h> __android_log_print(ANDROID_LOG_INFO, \"foo\", \"Something happened! x = %d\", x); If you need to build without optimization turned on, you can create a file called \"Application.mk\" in the jni directory, with the following line in it: APP_OPTIM := debug ================================================================================ Memory debugging ================================================================================ The best (and slowest) way to debug memory issues on Android is valgrind. Valgrind has support for Android out of the box, just grab code using: svn co svn://svn.valgrind.org/valgrind/trunk valgrind ... and follow the instructions in the file README.android to build it. One thing I needed to do on Mac OS X was change the path to the toolchain, and add ranlib to the environment variables: export RANLIB=$NDKROOT/toolchains/arm-linux-androideabi-4.4.3/prebuilt/darwin-x86/bin/arm-linux-androideabi-ranlib Once valgrind is built, you can create a wrapper script to launch your application with it, changing org.libsdl.app to your package identifier: --- start_valgrind_app ------------------- #!/system/bin/sh export TMPDIR=/data/data/org.libsdl.app exec /data/local/Inst/bin/valgrind --log-file=/sdcard/valgrind.log --error-limit=no $* ------------------------------------------ Then push it to the device: adb push start_valgrind_app /data/local and make it executable: adb shell chmod 755 /data/local/start_valgrind_app and tell Android to use the script to launch your application: adb shell setprop wrap.org.libsdl.app \"logwrapper /data/local/start_valgrind_app\" If the setprop command says \"could not set property\", it's likely that your package name is too long and you should make it shorter by changing AndroidManifest.xml and the path to your class file in android-project/src You can then launch your application normally and waaaaaaaiiittt for it. You can monitor the startup process with the logcat command above, and when it's done (or even while it's running) you can grab the valgrind output file: adb pull /sdcard/valgrind.log When you're done instrumenting with valgrind, you can disable the wrapper: adb shell setprop wrap.org.libsdl.app \"\" ================================================================================ Graphics debugging ================================================================================ If you are developing on a compatible Tegra-based tablet, NVidia provides Tegra Graphics Debugger at their website. Because SDL2 dynamically loads EGL and GLES libraries, you must follow their instructions for installing the interposer library on a rooted device. The non-rooted instructions are not compatible with applications that use SDL2 for video. The Tegra Graphics Debugger is available from NVidia here: https://developer.nvidia.com/tegra-graphics-debugger ================================================================================ Why is API level 16 the minimum required? ================================================================================ The latest NDK toolchain doesn't support targeting earlier than API level 16. As of this writing, according to https://developer.android.com/about/dashboards/index.html about 99% of the Android devices accessing Google Play support API level 16 or higher (January 2018). ================================================================================ A note regarding the use of the \"dirty rectangles\" rendering technique ================================================================================ If your app uses a variation of the \"dirty rectangles\" rendering technique, where you only update a portion of the screen on each frame, you may notice a variety of visual glitches on Android, that are not present on other platforms. This is caused by SDL's use of EGL as the support system to handle OpenGL ES/ES2 contexts, in particular the use of the eglSwapBuffers function. As stated in the documentation for the function \"The contents of ancillary buffers are always undefined after calling eglSwapBuffers\". Setting the EGL_SWAP_BEHAVIOR attribute of the surface to EGL_BUFFER_PRESERVED is not possible for SDL as it requires EGL 1.4, available only on the API level 17+, so the only workaround available on this platform is to redraw the entire screen each frame. Reference: http://www.khronos.org/registry/egl/specs/EGLTechNote0001.html ================================================================================ Ending your application ================================================================================ Two legitimate ways: return from your main() function. Java side will automatically terminate the Activity by calling Activity.finish(). Android OS can decide to terminate your application by calling onDestroy() (see Activity life cycle). Your application will receive a SDL_QUIT event you can handle to save things and quit. Don't call exit() as it stops the activity badly. NB: \"Back button\" can be handled as a SDL_KEYDOWN/UP events, with Keycode SDLK_AC_BACK, for any purpose. ================================================================================ Known issues ================================================================================ The number of buttons reported for each joystick is hardcoded to be 36, which is the current maximum number of buttons Android can report.","title":"Android"},{"location":"README-android/#android","text":"Matt Styles wrote a tutorial on building SDL for Android with Visual Studio: http://trederia.blogspot.de/2017/03/building-sdl2-for-android-with-visual.html The rest of this README covers the Android gradle style build process. If you are using the older ant build process, it is no longer officially supported, but you can use the \"android-project-ant\" directory as a template. ================================================================================ Requirements ================================================================================ Android SDK (version 26 or later) https://developer.android.com/sdk/index.html Android NDK r15c or later https://developer.android.com/tools/sdk/ndk/index.html Minimum API level supported by SDL: 16 (Android 4.1) ================================================================================ How the port works ================================================================================ Android applications are Java-based, optionally with parts written in C As SDL apps are C-based, we use a small Java shim that uses JNI to talk to the SDL library This means that your application C code must be placed inside an Android Java project, along with some C support code that communicates with Java This eventually produces a standard Android .apk package The Android Java code implements an \"Activity\" and can be found in: android-project/app/src/main/java/org/libsdl/app/SDLActivity.java The Java code loads your game code, the SDL shared library, and dispatches to native functions implemented in the SDL library: src/core/android/SDL_android.c ================================================================================ Building an app ================================================================================ For simple projects you can use the script located at build-scripts/androidbuild.sh There's two ways of using it: androidbuild.sh com.yourcompany.yourapp < sources.list androidbuild.sh com.yourcompany.yourapp source1.c source2.c ...sourceN.c sources.list should be a text file with a source file name in each line Filenames should be specified relative to the current directory, for example if you are in the build-scripts directory and want to create the testgles.c test, you'll run: ./androidbuild.sh org.libsdl.testgles ../test/testgles.c One limitation of this script is that all sources provided will be aggregated into a single directory, thus all your source files should have a unique name. Once the project is complete the script will tell you where the debug APK is located. If you want to create a signed release APK, you can use the project created by this utility to generate it. Finally, a word of caution: re running androidbuild.sh wipes any changes you may have done in the build directory for the app! For more complex projects, follow these instructions: Copy the android-project directory wherever you want to keep your projects and rename it to the name of your project. Move or symlink this SDL directory into the \" /app/jni\" directory Edit \" /app/jni/src/Android.mk\" to include your source files 4a. If you want to use Android Studio, simply open your directory and start building. 4b. If you want to build manually, run './gradlew installDebug' in the project directory. This compiles the .java, creates an .apk with the native code embedded, and installs it on any connected Android device If you already have a project that uses CMake, the instructions change somewhat: Do points 1 and 2 from the instruction above. Edit \" /app/build.gradle\" to comment out or remove sections containing ndk-build and uncomment the cmake sections. Add arguments to the CMake invocation as needed. Edit \" /app/jni/CMakeLists.txt\" to include your project (it defaults to adding the \"src\" subdirectory). Note that you'll have SDL2, SDL2main and SDL2-static as targets in your project, so you should have \"target_link_libraries(yourgame SDL2 SDL2main)\" in your CMakeLists.txt file. Also be aware that you should use add_library() instead of add_executable() for the target containing your \"main\" function. If you wish to use Android Studio, you can skip the last step. Run './gradlew installDebug' or './gradlew installRelease' in the project directory. It will build and install your .apk on any connected Android device Here's an explanation of the files in the Android project, so you can customize them: android-project/app build.gradle - build info including the application version and SDK src/main/AndroidManifest.xml - package manifest. Among others, it contains the class name of the main Activity and the package name of the application. jni/ - directory holding native code jni/Application.mk - Application JNI settings, including target platform and STL library jni/Android.mk - Android makefile that can call recursively the Android.mk files in all subdirectories jni/CMakeLists.txt - Top-level CMake project that adds SDL as a subproject jni/SDL/ - (symlink to) directory holding the SDL library files jni/SDL/Android.mk - Android makefile for creating the SDL shared library jni/src/ - directory holding your C/C++ source jni/src/Android.mk - Android makefile that you should customize to include your source code and any library references jni/src/CMakeLists.txt - CMake file that you may customize to include your source code and any library references src/main/assets/ - directory holding asset files for your application src/main/res/ - directory holding resources for your application src/main/res/mipmap-* - directories holding icons for different phone hardware src/main/res/values/strings.xml - strings used in your application, including the application name src/main/java/org/libsdl/app/SDLActivity.java - the Java class handling the initialization and binding to SDL. Be very careful changing this, as the SDL library relies on this implementation. You should instead subclass this for your application. ================================================================================ Customizing your application name ================================================================================ To customize your application name, edit AndroidManifest.xml and replace \"org.libsdl.app\" with an identifier for your product package. Then create a Java class extending SDLActivity and place it in a directory under src matching your package, e.g. src/com/gamemaker/game/MyGame.java Here's an example of a minimal class file: --- MyGame.java -------------------------- package com.gamemaker.game; import org.libsdl.app.SDLActivity; /** * A sample wrapper class that just calls SDLActivity */ public class MyGame extends SDLActivity { } ------------------------------------------ Then replace \"SDLActivity\" in AndroidManifest.xml with the name of your class, .e.g. \"MyGame\" ================================================================================ Customizing your application icon ================================================================================ Conceptually changing your icon is just replacing the \"ic_launcher.png\" files in the drawable directories under the res directory. There are several directories for different screen sizes. ================================================================================ Loading assets ================================================================================ Any files you put in the \"app/src/main/assets\" directory of your project directory will get bundled into the application package and you can load them using the standard functions in SDL_rwops.h. There are also a few Android specific functions that allow you to get other useful paths for saving and loading data: * SDL_AndroidGetInternalStoragePath() * SDL_AndroidGetExternalStorageState() * SDL_AndroidGetExternalStoragePath() See SDL_system.h for more details on these functions. The asset packaging system will, by default, compress certain file extensions. SDL includes two asset file access mechanisms, the preferred one is the so called \"File Descriptor\" method, which is faster and doesn't involve the Dalvik GC, but given this method does not work on compressed assets, there is also the \"Input Stream\" method, which is automatically used as a fall back by SDL. You may want to keep this fact in mind when building your APK, specially when large files are involved. For more information on which extensions get compressed by default and how to disable this behaviour, see for example: http://ponystyle.com/blog/2010/03/26/dealing-with-asset-compression-in-android-apps/ ================================================================================ Pause / Resume behaviour ================================================================================ If SDL_HINT_ANDROID_BLOCK_ON_PAUSE hint is set (the default), the event loop will block itself when the app is paused (ie, when the user returns to the main Android dashboard). Blocking is better in terms of battery use, and it allows your app to spring back to life instantaneously after resume (versus polling for a resume message). Upon resume, SDL will attempt to restore the GL context automatically. In modern devices (Android 3.0 and up) this will most likely succeed and your app can continue to operate as it was. However, there's a chance (on older hardware, or on systems under heavy load), where the GL context can not be restored. In that case you have to listen for a specific message (SDL_RENDER_DEVICE_RESET) and restore your textures manually or quit the app. You should not use the SDL renderer API while the app going in background: - SDL_APP_WILLENTERBACKGROUND: after you read this message, GL context gets backed-up and you should not use the SDL renderer API. SDL_APP_DIDENTERFOREGROUND: GL context is restored, and the SDL renderer API is available (unless you receive SDL_RENDER_DEVICE_RESET). ================================================================================ Mouse / Touch events ================================================================================ In some case, SDL generates synthetic mouse (resp. touch) events for touch (resp. mouse) devices. To enable/disable this behavior, see SDL_hints.h: - SDL_HINT_TOUCH_MOUSE_EVENTS - SDL_HINT_MOUSE_TOUCH_EVENTS ================================================================================ Misc ================================================================================ For some device, it appears to works better setting explicitly GL attributes before creating a window: SDL_GL_SetAttribute(SDL_GL_RED_SIZE, 5); SDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, 6); SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, 5); ================================================================================ Threads and the Java VM ================================================================================ For a quick tour on how Linux native threads interoperate with the Java VM, take a look here: https://developer.android.com/guide/practices/jni.html If you want to use threads in your SDL app, it's strongly recommended that you do so by creating them using SDL functions. This way, the required attach/detach handling is managed by SDL automagically. If you have threads created by other means and they make calls to SDL functions, make sure that you call Android_JNI_SetupThread() before doing anything else otherwise SDL will attach your thread automatically anyway (when you make an SDL call), but it'll never detach it. ================================================================================ Using STL ================================================================================ You can use STL in your project by creating an Application.mk file in the jni folder and adding the following line: APP_STL := c++_shared For more information go here: https://developer.android.com/ndk/guides/cpp-support ================================================================================ Using the emulator ================================================================================ There are some good tips and tricks for getting the most out of the emulator here: https://developer.android.com/tools/devices/emulator.html Especially useful is the info on setting up OpenGL ES 2.0 emulation. Notice that this software emulator is incredibly slow and needs a lot of disk space. Using a real device works better. ================================================================================ Troubleshooting ================================================================================ You can see if adb can see any devices with the following command: adb devices You can see the output of log messages on the default device with: adb logcat You can push files to the device with: adb push local_file remote_path_and_file You can push files to the SD Card at /sdcard, for example: adb push moose.dat /sdcard/moose.dat You can see the files on the SD card with a shell command: adb shell ls /sdcard/ You can start a command shell on the default device with: adb shell You can remove the library files of your project (and not the SDL lib files) with: ndk-build clean You can do a build with the following command: ndk-build You can see the complete command line that ndk-build is using by passing V=1 on the command line: ndk-build V=1 If your application crashes in native code, you can use ndk-stack to get a symbolic stack trace: https://developer.android.com/ndk/guides/ndk-stack If you want to go through the process manually, you can use addr2line to convert the addresses in the stack trace to lines in your code. For example, if your crash looks like this: I/DEBUG ( 31): signal 11 (SIGSEGV), code 2 (SEGV_ACCERR), fault addr 400085d0 I/DEBUG ( 31): r0 00000000 r1 00001000 r2 00000003 r3 400085d4 I/DEBUG ( 31): r4 400085d0 r5 40008000 r6 afd41504 r7 436c6a7c I/DEBUG ( 31): r8 436c6b30 r9 435c6fb0 10 435c6f9c fp 4168d82c I/DEBUG ( 31): ip 8346aff0 sp 436c6a60 lr afd1c8ff pc afd1c902 cpsr 60000030 I/DEBUG ( 31): #00 pc 0001c902 /system/lib/libc.so I/DEBUG ( 31): #01 pc 0001ccf6 /system/lib/libc.so I/DEBUG ( 31): #02 pc 000014bc /data/data/org.libsdl.app/lib/libmain.so I/DEBUG ( 31): #03 pc 00001506 /data/data/org.libsdl.app/lib/libmain.so You can see that there's a crash in the C library being called from the main code. I run addr2line with the debug version of my code: arm-eabi-addr2line -C -f -e obj/local/armeabi/libmain.so and then paste in the number after \"pc\" in the call stack, from the line that I care about: 000014bc I get output from addr2line showing that it's in the quit function, in testspriteminimal.c, on line 23. You can add logging to your code to help show what's happening: #include <android/log.h> __android_log_print(ANDROID_LOG_INFO, \"foo\", \"Something happened! x = %d\", x); If you need to build without optimization turned on, you can create a file called \"Application.mk\" in the jni directory, with the following line in it: APP_OPTIM := debug ================================================================================ Memory debugging ================================================================================ The best (and slowest) way to debug memory issues on Android is valgrind. Valgrind has support for Android out of the box, just grab code using: svn co svn://svn.valgrind.org/valgrind/trunk valgrind ... and follow the instructions in the file README.android to build it. One thing I needed to do on Mac OS X was change the path to the toolchain, and add ranlib to the environment variables: export RANLIB=$NDKROOT/toolchains/arm-linux-androideabi-4.4.3/prebuilt/darwin-x86/bin/arm-linux-androideabi-ranlib Once valgrind is built, you can create a wrapper script to launch your application with it, changing org.libsdl.app to your package identifier: --- start_valgrind_app ------------------- #!/system/bin/sh export TMPDIR=/data/data/org.libsdl.app exec /data/local/Inst/bin/valgrind --log-file=/sdcard/valgrind.log --error-limit=no $* ------------------------------------------ Then push it to the device: adb push start_valgrind_app /data/local and make it executable: adb shell chmod 755 /data/local/start_valgrind_app and tell Android to use the script to launch your application: adb shell setprop wrap.org.libsdl.app \"logwrapper /data/local/start_valgrind_app\" If the setprop command says \"could not set property\", it's likely that your package name is too long and you should make it shorter by changing AndroidManifest.xml and the path to your class file in android-project/src You can then launch your application normally and waaaaaaaiiittt for it. You can monitor the startup process with the logcat command above, and when it's done (or even while it's running) you can grab the valgrind output file: adb pull /sdcard/valgrind.log When you're done instrumenting with valgrind, you can disable the wrapper: adb shell setprop wrap.org.libsdl.app \"\" ================================================================================ Graphics debugging ================================================================================ If you are developing on a compatible Tegra-based tablet, NVidia provides Tegra Graphics Debugger at their website. Because SDL2 dynamically loads EGL and GLES libraries, you must follow their instructions for installing the interposer library on a rooted device. The non-rooted instructions are not compatible with applications that use SDL2 for video. The Tegra Graphics Debugger is available from NVidia here: https://developer.nvidia.com/tegra-graphics-debugger ================================================================================ Why is API level 16 the minimum required? ================================================================================ The latest NDK toolchain doesn't support targeting earlier than API level 16. As of this writing, according to https://developer.android.com/about/dashboards/index.html about 99% of the Android devices accessing Google Play support API level 16 or higher (January 2018). ================================================================================ A note regarding the use of the \"dirty rectangles\" rendering technique ================================================================================ If your app uses a variation of the \"dirty rectangles\" rendering technique, where you only update a portion of the screen on each frame, you may notice a variety of visual glitches on Android, that are not present on other platforms. This is caused by SDL's use of EGL as the support system to handle OpenGL ES/ES2 contexts, in particular the use of the eglSwapBuffers function. As stated in the documentation for the function \"The contents of ancillary buffers are always undefined after calling eglSwapBuffers\". Setting the EGL_SWAP_BEHAVIOR attribute of the surface to EGL_BUFFER_PRESERVED is not possible for SDL as it requires EGL 1.4, available only on the API level 17+, so the only workaround available on this platform is to redraw the entire screen each frame. Reference: http://www.khronos.org/registry/egl/specs/EGLTechNote0001.html ================================================================================ Ending your application ================================================================================ Two legitimate ways: return from your main() function. Java side will automatically terminate the Activity by calling Activity.finish(). Android OS can decide to terminate your application by calling onDestroy() (see Activity life cycle). Your application will receive a SDL_QUIT event you can handle to save things and quit. Don't call exit() as it stops the activity badly. NB: \"Back button\" can be handled as a SDL_KEYDOWN/UP events, with Keycode SDLK_AC_BACK, for any purpose. ================================================================================ Known issues ================================================================================ The number of buttons reported for each joystick is hardcoded to be 36, which is the current maximum number of buttons Android can report.","title":"Android"},{"location":"README-cmake/","text":"CMake (www.cmake.org) SDL's build system was traditionally based on autotools. Over time, this approach has suffered from several issues across the different supported platforms. To solve these problems, a new build system based on CMake is under development. It works in parallel to the legacy system, so users can experiment with it without complication. While still experimental, the build system should be usable on the following platforms: FreeBSD Linux VS.NET 2010 MinGW and Msys macOS, iOS, and tvOS, with support for XCode ================================================================================ Usage ================================================================================ Assuming the source for SDL is located at ~/sdl cd ~ mkdir build cd build cmake ../sdl This will build the static and dynamic versions of SDL in the ~/build directory. ================================================================================ Usage, iOS/tvOS ================================================================================ CMake 3.14+ natively includes support for iOS and tvOS. SDL binaries may be built using Xcode or Make, possibly among other build-systems. When using a recent version of CMake (3.14+), it should be possible to: build SDL for iOS, both static and dynamic build SDL test apps (as iOS/tvOS .app bundles) generate a working SDL_config.h for iOS (using SDL_config.h.cmake as a basis) To use, set the following CMake variables when running CMake's configuration stage: CMAKE_SYSTEM_NAME=<OS> (either iOS or tvOS ) CMAKE_OSX_SYSROOT=<SDK> (examples: iphoneos , iphonesimulator , iphoneos12.4 , /full/path/to/iPhoneOS.sdk , appletvos , appletvsimulator , appletvos12.4 , /full/path/to/AppleTVOS.sdk , etc.) CMAKE_OSX_ARCHITECTURES=<semicolon-separated list of CPU architectures> (example: \"arm64;armv7s;x86_64\") Examples (for iOS/tvOS): for iOS-Simulator, using the latest, installed SDK: cmake ~/sdl -DCMAKE_SYSTEM_NAME=iOS -DCMAKE_OSX_SYSROOT=iphonesimulator -DCMAKE_OSX_ARCHITECTURES=x86_64 for iOS-Device, using the latest, installed SDK, 64-bit only cmake ~/sdl -DCMAKE_SYSTEM_NAME=iOS -DCMAKE_OSX_SYSROOT=iphoneos -DCMAKE_OSX_ARCHITECTURES=arm64 for iOS-Device, using the latest, installed SDK, mixed 32/64 bit cmake ~/sdl -DCMAKE_SYSTEM_NAME=iOS -DCMAKE_OSX_SYSROOT=iphoneos -DCMAKE_OSX_ARCHITECTURES=\"arm64;armv7s\" for iOS-Device, using a specific SDK revision (iOS 12.4, in this example): cmake ~/sdl -DCMAKE_SYSTEM_NAME=iOS -DCMAKE_OSX_SYSROOT=iphoneos12.4 -DCMAKE_OSX_ARCHITECTURES=arm64 for iOS-Simulator, using the latest, installed SDK, and building SDL test apps (as .app bundles): cmake ~/sdl -DSDL_TEST=1 -DCMAKE_SYSTEM_NAME=iOS -DCMAKE_OSX_SYSROOT=iphonesimulator -DCMAKE_OSX_ARCHITECTURES=x86_64 for tvOS-Simulator, using the latest, installed SDK: cmake ~/sdl -DCMAKE_SYSTEM_NAME=tvOS -DCMAKE_OSX_SYSROOT=appletvsimulator -DCMAKE_OSX_ARCHITECTURES=x86_64 for tvOS-Device, using the latest, installed SDK: cmake ~/sdl -DCMAKE_SYSTEM_NAME=tvOS -DCMAKE_OSX_SYSROOT=appletvos -DCMAKE_OSX_ARCHITECTURES=arm64","title":"CMake"},{"location":"README-cmake/#cmake","text":"(www.cmake.org) SDL's build system was traditionally based on autotools. Over time, this approach has suffered from several issues across the different supported platforms. To solve these problems, a new build system based on CMake is under development. It works in parallel to the legacy system, so users can experiment with it without complication. While still experimental, the build system should be usable on the following platforms: FreeBSD Linux VS.NET 2010 MinGW and Msys macOS, iOS, and tvOS, with support for XCode ================================================================================ Usage ================================================================================ Assuming the source for SDL is located at ~/sdl cd ~ mkdir build cd build cmake ../sdl This will build the static and dynamic versions of SDL in the ~/build directory. ================================================================================ Usage, iOS/tvOS ================================================================================ CMake 3.14+ natively includes support for iOS and tvOS. SDL binaries may be built using Xcode or Make, possibly among other build-systems. When using a recent version of CMake (3.14+), it should be possible to: build SDL for iOS, both static and dynamic build SDL test apps (as iOS/tvOS .app bundles) generate a working SDL_config.h for iOS (using SDL_config.h.cmake as a basis) To use, set the following CMake variables when running CMake's configuration stage: CMAKE_SYSTEM_NAME=<OS> (either iOS or tvOS ) CMAKE_OSX_SYSROOT=<SDK> (examples: iphoneos , iphonesimulator , iphoneos12.4 , /full/path/to/iPhoneOS.sdk , appletvos , appletvsimulator , appletvos12.4 , /full/path/to/AppleTVOS.sdk , etc.) CMAKE_OSX_ARCHITECTURES=<semicolon-separated list of CPU architectures> (example: \"arm64;armv7s;x86_64\")","title":"CMake"},{"location":"README-directfb/","text":"DirectFB Supports: Hardware YUV overlays OpenGL - software only 2D/3D accelerations (depends on directfb driver) multiple displays windows What you need: DirectFB 1.0.1, 1.2.x, 1.3.0 Kernel-Framebuffer support: required: vesafb, radeonfb .... Mesa 7.0.x - optional for OpenGL /etc/directfbrc This file should contain the following lines to make your joystick work and avoid crashes: disable-module=joystick disable-module=cle266 disable-module=cyber5k no-linux-input-grab To disable to use x11 backend when DISPLAY variable is found use export SDL_DIRECTFB_X11_CHECK=0 To disable the use of linux input devices, i.e. multimice/multikeyboard support, use export SDL_DIRECTFB_LINUX_INPUT=0 To use hardware accelerated YUV-overlays for YUV-textures, use: export SDL_DIRECTFB_YUV_DIRECT=1 This is disabled by default. It will only support one YUV texture, namely the first. Every other YUV texture will be rendered in software. In addition, you may use (directfb-1.2.x) export SDL_DIRECTFB_YUV_UNDERLAY=1 to make the YUV texture an underlay. This will make the cursor to be shown. Simple Window Manager The driver has support for a very, very basic window manager you may want to use when running with \"wm=default\". Use export SDL_DIRECTFB_WM=1 to enable basic window borders. In order to have the window title rendered, you need to have the following font installed: /usr/share/fonts/truetype/freefont/FreeSans.ttf OpenGL Support The following instructions will give you software OpenGL. However this works at least on all directfb supported platforms. As of this writing 20100802 you need to pull Mesa from git and do the following: git clone git://anongit.freedesktop.org/git/mesa/mesa cd mesa git checkout 2c9fdaf7292423c157fc79b5ce43f0f199dd753a Edit configs/linux-directfb so that the Directories-section looks like Directories SRC_DIRS = mesa glu GLU_DIRS = sgi DRIVER_DIRS = directfb PROGRAM_DIRS = make linux-directfb make echo Installing - please enter sudo pw. sudo make install INSTALL_DIR=/usr/local/dfb_GL cd src/mesa/drivers/directfb make sudo make install INSTALL_DIR=/usr/local/dfb_GL To run the SDL - testprograms: export SDL_VIDEODRIVER=directfb export LD_LIBRARY_PATH=/usr/local/dfb_GL/lib export LD_PRELOAD=/usr/local/dfb_GL/libGL.so.7 ./testgl","title":"DirectFB"},{"location":"README-directfb/#directfb","text":"Supports: Hardware YUV overlays OpenGL - software only 2D/3D accelerations (depends on directfb driver) multiple displays windows What you need: DirectFB 1.0.1, 1.2.x, 1.3.0 Kernel-Framebuffer support: required: vesafb, radeonfb .... Mesa 7.0.x - optional for OpenGL /etc/directfbrc This file should contain the following lines to make your joystick work and avoid crashes: disable-module=joystick disable-module=cle266 disable-module=cyber5k no-linux-input-grab To disable to use x11 backend when DISPLAY variable is found use export SDL_DIRECTFB_X11_CHECK=0 To disable the use of linux input devices, i.e. multimice/multikeyboard support, use export SDL_DIRECTFB_LINUX_INPUT=0 To use hardware accelerated YUV-overlays for YUV-textures, use: export SDL_DIRECTFB_YUV_DIRECT=1 This is disabled by default. It will only support one YUV texture, namely the first. Every other YUV texture will be rendered in software. In addition, you may use (directfb-1.2.x) export SDL_DIRECTFB_YUV_UNDERLAY=1 to make the YUV texture an underlay. This will make the cursor to be shown.","title":"DirectFB"},{"location":"README-directfb/#simple-window-manager","text":"The driver has support for a very, very basic window manager you may want to use when running with \"wm=default\". Use export SDL_DIRECTFB_WM=1 to enable basic window borders. In order to have the window title rendered, you need to have the following font installed: /usr/share/fonts/truetype/freefont/FreeSans.ttf","title":"Simple Window Manager"},{"location":"README-directfb/#opengl-support","text":"The following instructions will give you software OpenGL. However this works at least on all directfb supported platforms. As of this writing 20100802 you need to pull Mesa from git and do the following: git clone git://anongit.freedesktop.org/git/mesa/mesa cd mesa git checkout 2c9fdaf7292423c157fc79b5ce43f0f199dd753a","title":"OpenGL Support"},{"location":"README-directfb/#edit-configslinux-directfb-so-that-the-directories-section-looks-like","text":"","title":"Edit configs/linux-directfb so that the Directories-section looks like"},{"location":"README-directfb/#directories","text":"SRC_DIRS = mesa glu GLU_DIRS = sgi DRIVER_DIRS = directfb PROGRAM_DIRS = make linux-directfb make echo Installing - please enter sudo pw. sudo make install INSTALL_DIR=/usr/local/dfb_GL cd src/mesa/drivers/directfb make sudo make install INSTALL_DIR=/usr/local/dfb_GL To run the SDL - testprograms: export SDL_VIDEODRIVER=directfb export LD_LIBRARY_PATH=/usr/local/dfb_GL/lib export LD_PRELOAD=/usr/local/dfb_GL/libGL.so.7 ./testgl","title":"Directories"},{"location":"README-dynapi/","text":"Dynamic API Originally posted by Ryan at: https://plus.google.com/103391075724026391227/posts/TB8UfnDYu4U Background: The Steam Runtime has (at least in theory) a really kick-ass build of SDL2, but developers are shipping their own SDL2 with individual Steam games. These games might stop getting updates, but a newer SDL2 might be needed later. Certainly we'll always be fixing bugs in SDL, even if a new video target isn't ever needed, and these fixes won't make it to a game shipping its own SDL. Even if we replace the SDL2 in those games with a compatible one, that is to say, edit a developer's Steam depot (yuck!), there are developers that are statically linking SDL2 that we can't do this for. We can't even force the dynamic loader to ignore their SDL2 in this case, of course. If you don't ship an SDL2 with the game in some form, people that disabled the Steam Runtime, or just tried to run the game from the command line instead of Steam might find themselves unable to run the game, due to a missing dependency. If you want to ship on non-Steam platforms like GOG or Humble Bundle, or target generic Linux boxes that may or may not have SDL2 installed, you have to ship the library or risk a total failure to launch. So now, you might have to have a non-Steam build plus a Steam build (that is, one with and one without SDL2 included), which is inconvenient if you could have had one universal build that works everywhere. We like the zlib license, but the biggest complaint from the open source community about the license change is the static linking. The LGPL forced this as a legal, not technical issue, but zlib doesn't care. Even those that aren't concerned about the GNU freedoms found themselves solving the same problems: swapping in a newer SDL to an older game often times can save the day. Static linking stops this dead. So here's what we did: SDL now has, internally, a table of function pointers. So, this is what SDL_Init now looks like: UInt32 SDL_Init(Uint32 flags) { return jump_table.SDL_Init(flags); } Except that is all done with a bunch of macro magic so we don't have to maintain every one of these. What is jump_table.SDL_init()? Eventually, that's a function pointer of the real SDL_Init() that you've been calling all this time. But at startup, it looks more like this: Uint32 SDL_Init_DEFAULT(Uint32 flags) { SDL_InitDynamicAPI(); return jump_table.SDL_Init(flags); } SDL_InitDynamicAPI() fills in jump_table with all the actual SDL function pointers, which means that this _DEFAULT function never gets called again. First call to any SDL function sets the whole thing up. So you might be asking, what was the value in that? Isn't this what the operating system's dynamic loader was supposed to do for us? Yes, but now we've got this level of indirection, we can do things like this: export SDL_DYNAMIC_API=/my/actual/libSDL-2.0.so.0 ./MyGameThatIsStaticallyLinkedToSDL2 And now, this game that is statically linked to SDL, can still be overridden with a newer, or better, SDL. The statically linked one will only be used as far as calling into the jump table in this case. But in cases where no override is desired, the statically linked version will provide its own jump table, and everyone is happy. So now: - Developers can statically link SDL, and users can still replace it. (We'd still rather you ship a shared library, though!) - Developers can ship an SDL with their game, Valve can override it for, say, new features on SteamOS, or distros can override it for their own needs, but it'll also just work in the default case. - Developers can ship the same package to everyone (Humble Bundle, GOG, etc), and it'll do the right thing. - End users (and Valve) can update a game's SDL in almost any case, to keep abandoned games running on newer platforms. - Everyone develops with SDL exactly as they have been doing all along. Same headers, same ABI. Just get the latest version to enable this magic. A little more about SDL_InitDynamicAPI(): Internally, InitAPI does some locking to make sure everything waits until a single thread initializes everything (although even SDL_CreateThread() goes through here before spinning a thread, too), and then decides if it should use an external SDL library. If not, it sets up the jump table using the current SDL's function pointers (which might be statically linked into a program, or in a shared library of its own). If so, it loads that library and looks for and calls a single function: SInt32 SDL_DYNAPI_entry(Uint32 version, void *table, Uint32 tablesize); That function takes a version number (more on that in a moment), the address of the jump table, and the size, in bytes, of the table. Now, we've got policy here: this table's layout never changes; new stuff gets added to the end. Therefore SDL_DYNAPI_entry() knows that it can provide all the needed functions if tablesize <= sizeof its own jump table. If tablesize is bigger (say, SDL 2.0.4 is trying to load SDL 2.0.3), then we know to abort, but if it's smaller, we know we can provide the entire API that the caller needs. The version variable is a failsafe switch. Right now it's always 1. This number changes when there are major API changes (so we know if the tablesize might be smaller, or entries in it have changed). Right now SDL_DYNAPI_entry gives up if the version doesn't match, but it's not inconceivable to have a small dispatch library that only supplies this one function and loads different, otherwise-incompatible SDL libraries and has the right one initialize the jump table based on the version. For something that must generically catch lots of different versions of SDL over time, like the Steam Client, this isn't a bad option. Finally, I'm sure some people are reading this and thinking, \"I don't want that overhead in my project!\" To which I would point out that the extra function call through the jump table probably wouldn't even show up in a profile, but lucky you: this can all be disabled. You can build SDL without this if you absolutely must, but we would encourage you not to do that. However, on heavily locked down platforms like iOS, or maybe when debugging, it makes sense to disable it. The way this is designed in SDL, you just have to change one #define, and the entire system vaporizes out, and SDL functions exactly like it always did. Most of it is macro magic, so the system is contained to one C file and a few headers. However, this is on by default and you have to edit a header file to turn it off. Our hopes is that if we make it easy to disable, but not too easy, everyone will ultimately be able to get what they want, but we've gently nudged everyone towards what we think is the best solution.","title":"DynAPI"},{"location":"README-dynapi/#dynamic-api","text":"Originally posted by Ryan at: https://plus.google.com/103391075724026391227/posts/TB8UfnDYu4U Background: The Steam Runtime has (at least in theory) a really kick-ass build of SDL2, but developers are shipping their own SDL2 with individual Steam games. These games might stop getting updates, but a newer SDL2 might be needed later. Certainly we'll always be fixing bugs in SDL, even if a new video target isn't ever needed, and these fixes won't make it to a game shipping its own SDL. Even if we replace the SDL2 in those games with a compatible one, that is to say, edit a developer's Steam depot (yuck!), there are developers that are statically linking SDL2 that we can't do this for. We can't even force the dynamic loader to ignore their SDL2 in this case, of course. If you don't ship an SDL2 with the game in some form, people that disabled the Steam Runtime, or just tried to run the game from the command line instead of Steam might find themselves unable to run the game, due to a missing dependency. If you want to ship on non-Steam platforms like GOG or Humble Bundle, or target generic Linux boxes that may or may not have SDL2 installed, you have to ship the library or risk a total failure to launch. So now, you might have to have a non-Steam build plus a Steam build (that is, one with and one without SDL2 included), which is inconvenient if you could have had one universal build that works everywhere. We like the zlib license, but the biggest complaint from the open source community about the license change is the static linking. The LGPL forced this as a legal, not technical issue, but zlib doesn't care. Even those that aren't concerned about the GNU freedoms found themselves solving the same problems: swapping in a newer SDL to an older game often times can save the day. Static linking stops this dead. So here's what we did: SDL now has, internally, a table of function pointers. So, this is what SDL_Init now looks like: UInt32 SDL_Init(Uint32 flags) { return jump_table.SDL_Init(flags); } Except that is all done with a bunch of macro magic so we don't have to maintain every one of these. What is jump_table.SDL_init()? Eventually, that's a function pointer of the real SDL_Init() that you've been calling all this time. But at startup, it looks more like this: Uint32 SDL_Init_DEFAULT(Uint32 flags) { SDL_InitDynamicAPI(); return jump_table.SDL_Init(flags); } SDL_InitDynamicAPI() fills in jump_table with all the actual SDL function pointers, which means that this _DEFAULT function never gets called again. First call to any SDL function sets the whole thing up. So you might be asking, what was the value in that? Isn't this what the operating system's dynamic loader was supposed to do for us? Yes, but now we've got this level of indirection, we can do things like this: export SDL_DYNAMIC_API=/my/actual/libSDL-2.0.so.0 ./MyGameThatIsStaticallyLinkedToSDL2 And now, this game that is statically linked to SDL, can still be overridden with a newer, or better, SDL. The statically linked one will only be used as far as calling into the jump table in this case. But in cases where no override is desired, the statically linked version will provide its own jump table, and everyone is happy. So now: - Developers can statically link SDL, and users can still replace it. (We'd still rather you ship a shared library, though!) - Developers can ship an SDL with their game, Valve can override it for, say, new features on SteamOS, or distros can override it for their own needs, but it'll also just work in the default case. - Developers can ship the same package to everyone (Humble Bundle, GOG, etc), and it'll do the right thing. - End users (and Valve) can update a game's SDL in almost any case, to keep abandoned games running on newer platforms. - Everyone develops with SDL exactly as they have been doing all along. Same headers, same ABI. Just get the latest version to enable this magic. A little more about SDL_InitDynamicAPI(): Internally, InitAPI does some locking to make sure everything waits until a single thread initializes everything (although even SDL_CreateThread() goes through here before spinning a thread, too), and then decides if it should use an external SDL library. If not, it sets up the jump table using the current SDL's function pointers (which might be statically linked into a program, or in a shared library of its own). If so, it loads that library and looks for and calls a single function: SInt32 SDL_DYNAPI_entry(Uint32 version, void *table, Uint32 tablesize); That function takes a version number (more on that in a moment), the address of the jump table, and the size, in bytes, of the table. Now, we've got policy here: this table's layout never changes; new stuff gets added to the end. Therefore SDL_DYNAPI_entry() knows that it can provide all the needed functions if tablesize <= sizeof its own jump table. If tablesize is bigger (say, SDL 2.0.4 is trying to load SDL 2.0.3), then we know to abort, but if it's smaller, we know we can provide the entire API that the caller needs. The version variable is a failsafe switch. Right now it's always 1. This number changes when there are major API changes (so we know if the tablesize might be smaller, or entries in it have changed). Right now SDL_DYNAPI_entry gives up if the version doesn't match, but it's not inconceivable to have a small dispatch library that only supplies this one function and loads different, otherwise-incompatible SDL libraries and has the right one initialize the jump table based on the version. For something that must generically catch lots of different versions of SDL over time, like the Steam Client, this isn't a bad option. Finally, I'm sure some people are reading this and thinking, \"I don't want that overhead in my project!\" To which I would point out that the extra function call through the jump table probably wouldn't even show up in a profile, but lucky you: this can all be disabled. You can build SDL without this if you absolutely must, but we would encourage you not to do that. However, on heavily locked down platforms like iOS, or maybe when debugging, it makes sense to disable it. The way this is designed in SDL, you just have to change one #define, and the entire system vaporizes out, and SDL functions exactly like it always did. Most of it is macro magic, so the system is contained to one C file and a few headers. However, this is on by default and you have to edit a header file to turn it off. Our hopes is that if we make it easy to disable, but not too easy, everyone will ultimately be able to get what they want, but we've gently nudged everyone towards what we think is the best solution.","title":"Dynamic API"},{"location":"README-emscripten/","text":"Emscripten Build: $ mkdir build $ cd build $ emconfigure ../configure --host=asmjs-unknown-emscripten --disable-assembly --disable-threads --disable-cpuinfo CFLAGS=\"-O2\" $ emmake make Or with cmake: $ mkdir build $ cd build $ emcmake cmake .. $ emmake make To build one of the tests: $ cd test/ $ emcc -O2 --js-opts 0 -g4 testdraw2.c -I../include ../build/.libs/libSDL2.a ../build/libSDL2_test.a -o a.html Uses GLES2 renderer or software Some other SDL2 libraries can be easily built (assuming SDL2 is installed somewhere): SDL_mixer (http://www.libsdl.org/projects/SDL_mixer/): $ EMCONFIGURE_JS=1 emconfigure ../configure build as usual... SDL_gfx (http://cms.ferzkopp.net/index.php/software/13-sdl-gfx): $ EMCONFIGURE_JS=1 emconfigure ../configure --disable-mmx build as usual...","title":"Empscripten"},{"location":"README-emscripten/#emscripten","text":"Build: $ mkdir build $ cd build $ emconfigure ../configure --host=asmjs-unknown-emscripten --disable-assembly --disable-threads --disable-cpuinfo CFLAGS=\"-O2\" $ emmake make Or with cmake: $ mkdir build $ cd build $ emcmake cmake .. $ emmake make To build one of the tests: $ cd test/ $ emcc -O2 --js-opts 0 -g4 testdraw2.c -I../include ../build/.libs/libSDL2.a ../build/libSDL2_test.a -o a.html Uses GLES2 renderer or software Some other SDL2 libraries can be easily built (assuming SDL2 is installed somewhere): SDL_mixer (http://www.libsdl.org/projects/SDL_mixer/): $ EMCONFIGURE_JS=1 emconfigure ../configure build as usual... SDL_gfx (http://cms.ferzkopp.net/index.php/software/13-sdl-gfx): $ EMCONFIGURE_JS=1 emconfigure ../configure --disable-mmx build as usual...","title":"Emscripten"},{"location":"README-gesture/","text":"Dollar Gestures SDL provides an implementation of the $1 gesture recognition system. This allows for recording, saving, loading, and performing single stroke gestures. Gestures can be performed with any number of fingers (the centroid of the fingers must follow the path of the gesture), but the number of fingers must be constant (a finger cannot go down in the middle of a gesture). The path of a gesture is considered the path from the time when the final finger went down, to the first time any finger comes up. Dollar gestures are assigned an Id based on a hash function. This is guaranteed to remain constant for a given gesture. There is a (small) chance that two different gestures will be assigned the same ID. In this case, simply re-recording one of the gestures should result in a different ID. Recording: To begin recording on a touch device call: SDL_RecordGesture(SDL_TouchID touchId), where touchId is the id of the touch device you wish to record on, or -1 to record on all connected devices. Recording terminates as soon as a finger comes up. Recording is acknowledged by an SDL_DOLLARRECORD event. A SDL_DOLLARRECORD event is a dgesture with the following fields: event.dgesture.touchId - the Id of the touch used to record the gesture. event.dgesture.gestureId - the unique id of the recorded gesture. Performing: As long as there is a dollar gesture assigned to a touch, every finger-up event will also cause an SDL_DOLLARGESTURE event with the following fields: event.dgesture.touchId - the Id of the touch which performed the gesture. event.dgesture.gestureId - the unique id of the closest gesture to the performed stroke. event.dgesture.error - the difference between the gesture template and the actual performed gesture. Lower error is a better match. event.dgesture.numFingers - the number of fingers used to draw the stroke. Most programs will want to define an appropriate error threshold and check to be sure that the error of a gesture is not abnormally high (an indicator that no gesture was performed). Saving: To save a template, call SDL_SaveDollarTemplate(gestureId, dst) where gestureId is the id of the gesture you want to save, and dst is an SDL_RWops pointer to the file where the gesture will be stored. To save all currently loaded templates, call SDL_SaveAllDollarTemplates(dst) where dst is an SDL_RWops pointer to the file where the gesture will be stored. Both functions return the number of gestures successfully saved. Loading: To load templates from a file, call SDL_LoadDollarTemplates(touchId,src) where touchId is the id of the touch to load to (or -1 to load to all touch devices), and src is an SDL_RWops pointer to a gesture save file. SDL_LoadDollarTemplates returns the number of templates successfully loaded. =========================================================================== Multi Gestures =========================================================================== SDL provides simple support for pinch/rotate/swipe gestures. Every time a finger is moved an SDL_MULTIGESTURE event is sent with the following fields: event.mgesture.touchId - the Id of the touch on which the gesture was performed. event.mgesture.x - the normalized x coordinate of the gesture. (0..1) event.mgesture.y - the normalized y coordinate of the gesture. (0..1) event.mgesture.dTheta - the amount that the fingers rotated during this motion. event.mgesture.dDist - the amount that the fingers pinched during this motion. event.mgesture.numFingers - the number of fingers used in the gesture. =========================================================================== Notes =========================================================================== For a complete example see test/testgesture.c Please direct questions/comments to: jim.tla+sdl_touch@gmail.com","title":"Gestures"},{"location":"README-gesture/#dollar-gestures","text":"SDL provides an implementation of the $1 gesture recognition system. This allows for recording, saving, loading, and performing single stroke gestures. Gestures can be performed with any number of fingers (the centroid of the fingers must follow the path of the gesture), but the number of fingers must be constant (a finger cannot go down in the middle of a gesture). The path of a gesture is considered the path from the time when the final finger went down, to the first time any finger comes up. Dollar gestures are assigned an Id based on a hash function. This is guaranteed to remain constant for a given gesture. There is a (small) chance that two different gestures will be assigned the same ID. In this case, simply re-recording one of the gestures should result in a different ID.","title":"Dollar Gestures"},{"location":"README-gesture/#recording","text":"To begin recording on a touch device call: SDL_RecordGesture(SDL_TouchID touchId), where touchId is the id of the touch device you wish to record on, or -1 to record on all connected devices. Recording terminates as soon as a finger comes up. Recording is acknowledged by an SDL_DOLLARRECORD event. A SDL_DOLLARRECORD event is a dgesture with the following fields: event.dgesture.touchId - the Id of the touch used to record the gesture. event.dgesture.gestureId - the unique id of the recorded gesture.","title":"Recording:"},{"location":"README-gesture/#performing","text":"As long as there is a dollar gesture assigned to a touch, every finger-up event will also cause an SDL_DOLLARGESTURE event with the following fields: event.dgesture.touchId - the Id of the touch which performed the gesture. event.dgesture.gestureId - the unique id of the closest gesture to the performed stroke. event.dgesture.error - the difference between the gesture template and the actual performed gesture. Lower error is a better match. event.dgesture.numFingers - the number of fingers used to draw the stroke. Most programs will want to define an appropriate error threshold and check to be sure that the error of a gesture is not abnormally high (an indicator that no gesture was performed).","title":"Performing:"},{"location":"README-gesture/#saving","text":"To save a template, call SDL_SaveDollarTemplate(gestureId, dst) where gestureId is the id of the gesture you want to save, and dst is an SDL_RWops pointer to the file where the gesture will be stored. To save all currently loaded templates, call SDL_SaveAllDollarTemplates(dst) where dst is an SDL_RWops pointer to the file where the gesture will be stored. Both functions return the number of gestures successfully saved.","title":"Saving:"},{"location":"README-gesture/#loading","text":"To load templates from a file, call SDL_LoadDollarTemplates(touchId,src) where touchId is the id of the touch to load to (or -1 to load to all touch devices), and src is an SDL_RWops pointer to a gesture save file. SDL_LoadDollarTemplates returns the number of templates successfully loaded. =========================================================================== Multi Gestures =========================================================================== SDL provides simple support for pinch/rotate/swipe gestures. Every time a finger is moved an SDL_MULTIGESTURE event is sent with the following fields: event.mgesture.touchId - the Id of the touch on which the gesture was performed. event.mgesture.x - the normalized x coordinate of the gesture. (0..1) event.mgesture.y - the normalized y coordinate of the gesture. (0..1) event.mgesture.dTheta - the amount that the fingers rotated during this motion. event.mgesture.dDist - the amount that the fingers pinched during this motion. event.mgesture.numFingers - the number of fingers used in the gesture. =========================================================================== Notes =========================================================================== For a complete example see test/testgesture.c Please direct questions/comments to: jim.tla+sdl_touch@gmail.com","title":"Loading:"},{"location":"README-git/","text":"git The latest development version of SDL is available via git. Git allows you to get up-to-the-minute fixes and enhancements; as a developer works on a source tree, you can use \"git\" to mirror that source tree instead of waiting for an official release. Please look at the Git website ( https://git-scm.com/ ) for more information on using git, where you can also download software for macOS, Windows, and Unix systems. git clone https://github.com/libsdl-org/SDL If you are building SDL via configure, you will need to run autogen.sh before running configure. There is a web interface to the Git repository at: https://github.com/libsdl-org/SDL/","title":"Git"},{"location":"README-git/#git","text":"The latest development version of SDL is available via git. Git allows you to get up-to-the-minute fixes and enhancements; as a developer works on a source tree, you can use \"git\" to mirror that source tree instead of waiting for an official release. Please look at the Git website ( https://git-scm.com/ ) for more information on using git, where you can also download software for macOS, Windows, and Unix systems. git clone https://github.com/libsdl-org/SDL If you are building SDL via configure, you will need to run autogen.sh before running configure. There is a web interface to the Git repository at: https://github.com/libsdl-org/SDL/","title":"git"},{"location":"README-hg/","text":"We are no longer hosted in Mercurial. Please see README-git.md for details. Thanks!","title":"HG"},{"location":"README-ios/","text":"iOS ============================================================================== Building the Simple DirectMedia Layer for iOS 5.1+ ============================================================================== Requirements: Mac OS X 10.8 or later and the iOS 7+ SDK. Instructions: Open SDL.xcodeproj (located in Xcode-iOS/SDL) in Xcode. Select your desired target, and hit build. There are three build targets: - libSDL.a: Build SDL as a statically linked library - testsdl: Build a test program (there are known test failures which are fine) - Template: Package a project template together with the SDL for iPhone static libraries and copies of the SDL headers. The template includes proper references to the SDL library and headers, skeleton code for a basic SDL program, and placeholder graphics for the application icon and startup screen. ============================================================================== Build SDL for iOS from the command line ============================================================================== cd (PATH WHERE THE SDL CODE IS)/build-scripts ./iosbuild.sh If everything goes fine, you should see a build/ios directory, inside there's two directories \"lib\" and \"include\". \"include\" contains a copy of the SDL headers that you'll need for your project, make sure to configure XCode to look for headers there. \"lib\" contains find two files, libSDL2.a and libSDL2main.a, you have to add both to your XCode project. These libraries contain three architectures in them, armv6 for legacy devices, armv7, and i386 (for the simulator). By default, iosbuild.sh will autodetect the SDK version you have installed using xcodebuild -showsdks, and build for iOS >= 3.0, you can override this behaviour by setting the MIN_OS_VERSION variable, ie: MIN_OS_VERSION=4.2 ./iosbuild.sh ============================================================================== Using the Simple DirectMedia Layer for iOS ============================================================================== FIXME: This needs to be updated for the latest methods Here is the easiest method: 1. Build the SDL library (libSDL2.a) and the iPhone SDL Application template. 2. Install the iPhone SDL Application template by copying it to one of Xcode's template directories. I recommend creating a directory called \"SDL\" in \"/Developer/Platforms/iOS.platform/Developer/Library/Xcode/Project Templates/\" and placing it there. 3. Start a new project using the template. The project should be immediately ready for use with SDL. Here is a more manual method: 1. Create a new iOS view based application. 2. Build the SDL static library (libSDL2.a) for iOS and include them in your project. Xcode will ignore the library that is not currently of the correct architecture, hence your app will work both on iOS and in the iOS Simulator. 3. Include the SDL header files in your project. 4. Remove the ApplicationDelegate.h and ApplicationDelegate.m files -- SDL for iOS provides its own UIApplicationDelegate. Remove MainWindow.xib -- SDL for iOS produces its user interface programmatically. 5. Delete the contents of main.m and program your app as a regular SDL program instead. You may replace main.m with your own main.c, but you must tell Xcode not to use the project prefix file, as it includes Objective-C code. ============================================================================== Notes -- Retina / High-DPI and window sizes ============================================================================== Window and display mode sizes in SDL are in \"screen coordinates\" (or \"points\", in Apple's terminology) rather than in pixels. On iOS this means that a window created on an iPhone 6 will have a size in screen coordinates of 375 x 667, rather than a size in pixels of 750 x 1334. All iOS apps are expected to size their content based on screen coordinates / points rather than pixels, as this allows different iOS devices to have different pixel densities (Retina versus non-Retina screens, etc.) without apps caring too much. By default SDL will not use the full pixel density of the screen on Retina/high-dpi capable devices. Use the SDL_WINDOW_ALLOW_HIGHDPI flag when creating your window to enable high-dpi support. When high-dpi support is enabled, SDL_GetWindowSize() and display mode sizes will still be in \"screen coordinates\" rather than pixels, but the window will have a much greater pixel density when the device supports it, and the SDL_GL_GetDrawableSize() or SDL_GetRendererOutputSize() functions (depending on whether raw OpenGL or the SDL_Render API is used) can be queried to determine the size in pixels of the drawable screen framebuffer. Some OpenGL ES functions such as glViewport expect sizes in pixels rather than sizes in screen coordinates. When doing 2D rendering with OpenGL ES, an orthographic projection matrix using the size in screen coordinates (SDL_GetWindowSize()) can be used in order to display content at the same scale no matter whether a Retina device is used or not. ============================================================================== Notes -- Application events ============================================================================== On iOS the application goes through a fixed life cycle and you will get notifications of state changes via application events. When these events are delivered you must handle them in an event callback because the OS may not give you any processing time after the events are delivered. e.g. int HandleAppEvents(void *userdata, SDL_Event *event) { switch (event->type) { case SDL_APP_TERMINATING: /* Terminate the app. Shut everything down before returning from this function. */ return 0; case SDL_APP_LOWMEMORY: /* You will get this when your app is paused and iOS wants more memory. Release as much memory as possible. */ return 0; case SDL_APP_WILLENTERBACKGROUND: /* Prepare your app to go into the background. Stop loops, etc. This gets called when the user hits the home button, or gets a call. */ return 0; case SDL_APP_DIDENTERBACKGROUND: /* This will get called if the user accepted whatever sent your app to the background. If the user got a phone call and canceled it, you'll instead get an SDL_APP_DIDENTERFOREGROUND event and restart your loops. When you get this, you have 5 seconds to save all your state or the app will be terminated. Your app is NOT active at this point. */ return 0; case SDL_APP_WILLENTERFOREGROUND: /* This call happens when your app is coming back to the foreground. Restore all your state here. */ return 0; case SDL_APP_DIDENTERFOREGROUND: /* Restart your loops here. Your app is interactive and getting CPU again. */ return 0; default: /* No special processing, add it to the event queue */ return 1; } } int main(int argc, char *argv[]) { SDL_SetEventFilter(HandleAppEvents, NULL); ... run your main loop return 0; } ============================================================================== Notes -- Accelerometer as Joystick ============================================================================== SDL for iPhone supports polling the built in accelerometer as a joystick device. For an example on how to do this, see the accelerometer.c in the demos directory. The main thing to note when using the accelerometer with SDL is that while the iPhone natively reports accelerometer as floating point values in units of g-force, SDL_JoystickGetAxis() reports joystick values as signed integers. Hence, in order to convert between the two, some clamping and scaling is necessary on the part of the iPhone SDL joystick driver. To convert SDL_JoystickGetAxis() reported values BACK to units of g-force, simply multiply the values by SDL_IPHONE_MAX_GFORCE / 0x7FFF. ============================================================================== Notes -- OpenGL ES ============================================================================== Your SDL application for iOS uses OpenGL ES for video by default. OpenGL ES for iOS supports several display pixel formats, such as RGBA8 and RGB565, which provide a 32 bit and 16 bit color buffer respectively. By default, the implementation uses RGB565, but you may use RGBA8 by setting each color component to 8 bits in SDL_GL_SetAttribute(). If your application doesn't use OpenGL's depth buffer, you may find significant performance improvement by setting SDL_GL_DEPTH_SIZE to 0. Finally, if your application completely redraws the screen each frame, you may find significant performance improvement by setting the attribute SDL_GL_RETAINED_BACKING to 0. OpenGL ES on iOS doesn't use the traditional system-framebuffer setup provided in other operating systems. Special care must be taken because of this: The drawable Renderbuffer must be bound to the GL_RENDERBUFFER binding point when SDL_GL_SwapWindow() is called. The drawable Framebuffer Object must be bound while rendering to the screen and when SDL_GL_SwapWindow() is called. If multisample antialiasing (MSAA) is used and glReadPixels is used on the screen, the drawable framebuffer must be resolved to the MSAA resolve framebuffer (via glBlitFramebuffer or glResolveMultisampleFramebufferAPPLE), and the MSAA resolve framebuffer must be bound to the GL_READ_FRAMEBUFFER binding point, before glReadPixels is called. The above objects can be obtained via SDL_GetWindowWMInfo() (in SDL_syswm.h). ============================================================================== Notes -- Keyboard ============================================================================== The SDL keyboard API has been extended to support on-screen keyboards: void SDL_StartTextInput() -- enables text events and reveals the onscreen keyboard. void SDL_StopTextInput() -- disables text events and hides the onscreen keyboard. SDL_bool SDL_IsTextInputActive() -- returns whether or not text events are enabled (and the onscreen keyboard is visible) ============================================================================== Notes -- Reading and Writing files ============================================================================== Each application installed on iPhone resides in a sandbox which includes its own Application Home directory. Your application may not access files outside this directory. Once your application is installed its directory tree looks like: MySDLApp Home/ MySDLApp.app Documents/ Library/ Preferences/ tmp/ When your SDL based iPhone application starts up, it sets the working directory to the main bundle (MySDLApp Home/MySDLApp.app), where your application resources are stored. You cannot write to this directory. Instead, I advise you to write document files to \"../Documents/\" and preferences to \"../Library/Preferences\". More information on this subject is available here: http://developer.apple.com/library/ios/#documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html ============================================================================== Notes -- iPhone SDL limitations ============================================================================== Windows: Full-size, single window applications only. You cannot create multi-window SDL applications for iPhone OS. The application window will fill the display, though you have the option of turning on or off the menu-bar (pass SDL_CreateWindow() the flag SDL_WINDOW_BORDERLESS). Textures: The optimal texture formats on iOS are SDL_PIXELFORMAT_ABGR8888, SDL_PIXELFORMAT_ABGR8888, SDL_PIXELFORMAT_BGR888, and SDL_PIXELFORMAT_RGB24 pixel formats. Loading Shared Objects: This is disabled by default since it seems to break the terms of the iOS SDK agreement for iOS versions prior to iOS 8. It can be re-enabled in SDL_config_iphoneos.h. ============================================================================== Notes -- CoreBluetooth.framework ============================================================================== SDL_JOYSTICK_HIDAPI is disabled by default. It can give you access to a lot more game controller devices, but it requires permission from the user before your app will be able to talk to the Bluetooth hardware. \"Made For iOS\" branded controllers do not need this as we don't have to speak to them directly with raw bluetooth, so many apps can live without this. You'll need to link with CoreBluetooth.framework and add something like this to your Info.plist: NSBluetoothPeripheralUsageDescription MyApp would like to remain connected to nearby bluetooth Game Controllers and Game Pads even when you're not using the app. ============================================================================== Game Center ============================================================================== Game Center integration might require that you break up your main loop in order to yield control back to the system. In other words, instead of running an endless main loop, you run each frame in a callback function, using: int SDL_iPhoneSetAnimationCallback(SDL_Window * window, int interval, void (*callback)(void*), void *callbackParam); This will set up the given function to be called back on the animation callback, and then you have to return from main() to let the Cocoa event loop run. e.g. extern \"C\" void ShowFrame(void*) { ... do event handling, frame logic and rendering ... } int main(int argc, char *argv[]) { ... initialize game ... #if __IPHONEOS__ // Initialize the Game Center for scoring and matchmaking InitGameCenter(); // Set up the game to run in the window animation callback on iOS // so that Game Center and so forth works correctly. SDL_iPhoneSetAnimationCallback(window, 1, ShowFrame, NULL); #else while ( running ) { ShowFrame(0); DelayFrame(); } #endif return 0; } ============================================================================== Deploying to older versions of iOS ============================================================================== SDL supports deploying to older versions of iOS than are supported by the latest version of Xcode, all the way back to iOS 6.1 In order to do that you need to download an older version of Xcode: https://developer.apple.com/download/more/?name=Xcode Open the package contents of the older Xcode and your newer version of Xcode and copy over the folders in Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport Then open the file Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/SDKSettings.plist and add the versions of iOS you want to deploy to the key Root/DefaultProperties/DEPLOYMENT_TARGET_SUGGESTED_VALUES Open your project and set your deployment target to the desired version of iOS Finally, remove GameController from the list of frameworks linked by your application and edit the build settings for \"Other Linker Flags\" and add -weak_framework GameController","title":"iOS"},{"location":"README-ios/#ios","text":"============================================================================== Building the Simple DirectMedia Layer for iOS 5.1+ ============================================================================== Requirements: Mac OS X 10.8 or later and the iOS 7+ SDK. Instructions: Open SDL.xcodeproj (located in Xcode-iOS/SDL) in Xcode. Select your desired target, and hit build. There are three build targets: - libSDL.a: Build SDL as a statically linked library - testsdl: Build a test program (there are known test failures which are fine) - Template: Package a project template together with the SDL for iPhone static libraries and copies of the SDL headers. The template includes proper references to the SDL library and headers, skeleton code for a basic SDL program, and placeholder graphics for the application icon and startup screen. ============================================================================== Build SDL for iOS from the command line ============================================================================== cd (PATH WHERE THE SDL CODE IS)/build-scripts ./iosbuild.sh If everything goes fine, you should see a build/ios directory, inside there's two directories \"lib\" and \"include\". \"include\" contains a copy of the SDL headers that you'll need for your project, make sure to configure XCode to look for headers there. \"lib\" contains find two files, libSDL2.a and libSDL2main.a, you have to add both to your XCode project. These libraries contain three architectures in them, armv6 for legacy devices, armv7, and i386 (for the simulator). By default, iosbuild.sh will autodetect the SDK version you have installed using xcodebuild -showsdks, and build for iOS >= 3.0, you can override this behaviour by setting the MIN_OS_VERSION variable, ie: MIN_OS_VERSION=4.2 ./iosbuild.sh ============================================================================== Using the Simple DirectMedia Layer for iOS ============================================================================== FIXME: This needs to be updated for the latest methods Here is the easiest method: 1. Build the SDL library (libSDL2.a) and the iPhone SDL Application template. 2. Install the iPhone SDL Application template by copying it to one of Xcode's template directories. I recommend creating a directory called \"SDL\" in \"/Developer/Platforms/iOS.platform/Developer/Library/Xcode/Project Templates/\" and placing it there. 3. Start a new project using the template. The project should be immediately ready for use with SDL. Here is a more manual method: 1. Create a new iOS view based application. 2. Build the SDL static library (libSDL2.a) for iOS and include them in your project. Xcode will ignore the library that is not currently of the correct architecture, hence your app will work both on iOS and in the iOS Simulator. 3. Include the SDL header files in your project. 4. Remove the ApplicationDelegate.h and ApplicationDelegate.m files -- SDL for iOS provides its own UIApplicationDelegate. Remove MainWindow.xib -- SDL for iOS produces its user interface programmatically. 5. Delete the contents of main.m and program your app as a regular SDL program instead. You may replace main.m with your own main.c, but you must tell Xcode not to use the project prefix file, as it includes Objective-C code. ============================================================================== Notes -- Retina / High-DPI and window sizes ============================================================================== Window and display mode sizes in SDL are in \"screen coordinates\" (or \"points\", in Apple's terminology) rather than in pixels. On iOS this means that a window created on an iPhone 6 will have a size in screen coordinates of 375 x 667, rather than a size in pixels of 750 x 1334. All iOS apps are expected to size their content based on screen coordinates / points rather than pixels, as this allows different iOS devices to have different pixel densities (Retina versus non-Retina screens, etc.) without apps caring too much. By default SDL will not use the full pixel density of the screen on Retina/high-dpi capable devices. Use the SDL_WINDOW_ALLOW_HIGHDPI flag when creating your window to enable high-dpi support. When high-dpi support is enabled, SDL_GetWindowSize() and display mode sizes will still be in \"screen coordinates\" rather than pixels, but the window will have a much greater pixel density when the device supports it, and the SDL_GL_GetDrawableSize() or SDL_GetRendererOutputSize() functions (depending on whether raw OpenGL or the SDL_Render API is used) can be queried to determine the size in pixels of the drawable screen framebuffer. Some OpenGL ES functions such as glViewport expect sizes in pixels rather than sizes in screen coordinates. When doing 2D rendering with OpenGL ES, an orthographic projection matrix using the size in screen coordinates (SDL_GetWindowSize()) can be used in order to display content at the same scale no matter whether a Retina device is used or not. ============================================================================== Notes -- Application events ============================================================================== On iOS the application goes through a fixed life cycle and you will get notifications of state changes via application events. When these events are delivered you must handle them in an event callback because the OS may not give you any processing time after the events are delivered. e.g. int HandleAppEvents(void *userdata, SDL_Event *event) { switch (event->type) { case SDL_APP_TERMINATING: /* Terminate the app. Shut everything down before returning from this function. */ return 0; case SDL_APP_LOWMEMORY: /* You will get this when your app is paused and iOS wants more memory. Release as much memory as possible. */ return 0; case SDL_APP_WILLENTERBACKGROUND: /* Prepare your app to go into the background. Stop loops, etc. This gets called when the user hits the home button, or gets a call. */ return 0; case SDL_APP_DIDENTERBACKGROUND: /* This will get called if the user accepted whatever sent your app to the background. If the user got a phone call and canceled it, you'll instead get an SDL_APP_DIDENTERFOREGROUND event and restart your loops. When you get this, you have 5 seconds to save all your state or the app will be terminated. Your app is NOT active at this point. */ return 0; case SDL_APP_WILLENTERFOREGROUND: /* This call happens when your app is coming back to the foreground. Restore all your state here. */ return 0; case SDL_APP_DIDENTERFOREGROUND: /* Restart your loops here. Your app is interactive and getting CPU again. */ return 0; default: /* No special processing, add it to the event queue */ return 1; } } int main(int argc, char *argv[]) { SDL_SetEventFilter(HandleAppEvents, NULL); ... run your main loop return 0; } ============================================================================== Notes -- Accelerometer as Joystick ============================================================================== SDL for iPhone supports polling the built in accelerometer as a joystick device. For an example on how to do this, see the accelerometer.c in the demos directory. The main thing to note when using the accelerometer with SDL is that while the iPhone natively reports accelerometer as floating point values in units of g-force, SDL_JoystickGetAxis() reports joystick values as signed integers. Hence, in order to convert between the two, some clamping and scaling is necessary on the part of the iPhone SDL joystick driver. To convert SDL_JoystickGetAxis() reported values BACK to units of g-force, simply multiply the values by SDL_IPHONE_MAX_GFORCE / 0x7FFF. ============================================================================== Notes -- OpenGL ES ============================================================================== Your SDL application for iOS uses OpenGL ES for video by default. OpenGL ES for iOS supports several display pixel formats, such as RGBA8 and RGB565, which provide a 32 bit and 16 bit color buffer respectively. By default, the implementation uses RGB565, but you may use RGBA8 by setting each color component to 8 bits in SDL_GL_SetAttribute(). If your application doesn't use OpenGL's depth buffer, you may find significant performance improvement by setting SDL_GL_DEPTH_SIZE to 0. Finally, if your application completely redraws the screen each frame, you may find significant performance improvement by setting the attribute SDL_GL_RETAINED_BACKING to 0. OpenGL ES on iOS doesn't use the traditional system-framebuffer setup provided in other operating systems. Special care must be taken because of this: The drawable Renderbuffer must be bound to the GL_RENDERBUFFER binding point when SDL_GL_SwapWindow() is called. The drawable Framebuffer Object must be bound while rendering to the screen and when SDL_GL_SwapWindow() is called. If multisample antialiasing (MSAA) is used and glReadPixels is used on the screen, the drawable framebuffer must be resolved to the MSAA resolve framebuffer (via glBlitFramebuffer or glResolveMultisampleFramebufferAPPLE), and the MSAA resolve framebuffer must be bound to the GL_READ_FRAMEBUFFER binding point, before glReadPixels is called. The above objects can be obtained via SDL_GetWindowWMInfo() (in SDL_syswm.h). ============================================================================== Notes -- Keyboard ============================================================================== The SDL keyboard API has been extended to support on-screen keyboards: void SDL_StartTextInput() -- enables text events and reveals the onscreen keyboard. void SDL_StopTextInput() -- disables text events and hides the onscreen keyboard. SDL_bool SDL_IsTextInputActive() -- returns whether or not text events are enabled (and the onscreen keyboard is visible) ============================================================================== Notes -- Reading and Writing files ============================================================================== Each application installed on iPhone resides in a sandbox which includes its own Application Home directory. Your application may not access files outside this directory. Once your application is installed its directory tree looks like: MySDLApp Home/ MySDLApp.app Documents/ Library/ Preferences/ tmp/ When your SDL based iPhone application starts up, it sets the working directory to the main bundle (MySDLApp Home/MySDLApp.app), where your application resources are stored. You cannot write to this directory. Instead, I advise you to write document files to \"../Documents/\" and preferences to \"../Library/Preferences\". More information on this subject is available here: http://developer.apple.com/library/ios/#documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html ============================================================================== Notes -- iPhone SDL limitations ============================================================================== Windows: Full-size, single window applications only. You cannot create multi-window SDL applications for iPhone OS. The application window will fill the display, though you have the option of turning on or off the menu-bar (pass SDL_CreateWindow() the flag SDL_WINDOW_BORDERLESS). Textures: The optimal texture formats on iOS are SDL_PIXELFORMAT_ABGR8888, SDL_PIXELFORMAT_ABGR8888, SDL_PIXELFORMAT_BGR888, and SDL_PIXELFORMAT_RGB24 pixel formats. Loading Shared Objects: This is disabled by default since it seems to break the terms of the iOS SDK agreement for iOS versions prior to iOS 8. It can be re-enabled in SDL_config_iphoneos.h. ============================================================================== Notes -- CoreBluetooth.framework ============================================================================== SDL_JOYSTICK_HIDAPI is disabled by default. It can give you access to a lot more game controller devices, but it requires permission from the user before your app will be able to talk to the Bluetooth hardware. \"Made For iOS\" branded controllers do not need this as we don't have to speak to them directly with raw bluetooth, so many apps can live without this. You'll need to link with CoreBluetooth.framework and add something like this to your Info.plist: NSBluetoothPeripheralUsageDescription MyApp would like to remain connected to nearby bluetooth Game Controllers and Game Pads even when you're not using the app. ============================================================================== Game Center ============================================================================== Game Center integration might require that you break up your main loop in order to yield control back to the system. In other words, instead of running an endless main loop, you run each frame in a callback function, using: int SDL_iPhoneSetAnimationCallback(SDL_Window * window, int interval, void (*callback)(void*), void *callbackParam); This will set up the given function to be called back on the animation callback, and then you have to return from main() to let the Cocoa event loop run. e.g. extern \"C\" void ShowFrame(void*) { ... do event handling, frame logic and rendering ... } int main(int argc, char *argv[]) { ... initialize game ... #if __IPHONEOS__ // Initialize the Game Center for scoring and matchmaking InitGameCenter(); // Set up the game to run in the window animation callback on iOS // so that Game Center and so forth works correctly. SDL_iPhoneSetAnimationCallback(window, 1, ShowFrame, NULL); #else while ( running ) { ShowFrame(0); DelayFrame(); } #endif return 0; } ============================================================================== Deploying to older versions of iOS ============================================================================== SDL supports deploying to older versions of iOS than are supported by the latest version of Xcode, all the way back to iOS 6.1 In order to do that you need to download an older version of Xcode: https://developer.apple.com/download/more/?name=Xcode Open the package contents of the older Xcode and your newer version of Xcode and copy over the folders in Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport Then open the file Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/SDKSettings.plist and add the versions of iOS you want to deploy to the key Root/DefaultProperties/DEPLOYMENT_TARGET_SUGGESTED_VALUES Open your project and set your deployment target to the desired version of iOS Finally, remove GameController from the list of frameworks linked by your application and edit the build settings for \"Other Linker Flags\" and add -weak_framework GameController","title":"iOS"},{"location":"README-kmsbsd/","text":"KMSDRM on *BSD KMSDRM is supported on FreeBSD and OpenBSD. DragonFlyBSD is not tested yet, but should work. NetBSD isn't supported yet because the application will crash when creating the KMSDRM screen. WSCONS support has been brought back, but only as an input backend. It will not be brought back as a video backend to ease maintenance. OpenBSD note: Note that the video backend assumes that the user has read/write permissions to the /dev/drm* devices. SDL2 WSCONS input backend features It is keymap-aware; it will work properly with different keymaps. It has mouse support. Accent input is supported. Compose keys are supported. AltGr and Meta Shift keys work as intended. Partially working or no input on OpenBSD/NetBSD. The WSCONS input backend needs read/write access to the /dev/wskbd* devices, without which it will not work properly. /dev/wsmouse must also be read/write accessible, otherwise mouse input will not work. Partially working or no input on FreeBSD. The evdev devices are only accessible to the root user by default. Edit devfs rules to allow access to such devices. The /dev/kbd* devices are also only accessible to the root user by default. Edit devfs rules to allow access to such devices.","title":"KMSDRN"},{"location":"README-kmsbsd/#kmsdrm-on-bsd","text":"KMSDRM is supported on FreeBSD and OpenBSD. DragonFlyBSD is not tested yet, but should work. NetBSD isn't supported yet because the application will crash when creating the KMSDRM screen. WSCONS support has been brought back, but only as an input backend. It will not be brought back as a video backend to ease maintenance. OpenBSD note: Note that the video backend assumes that the user has read/write permissions to the /dev/drm* devices.","title":"KMSDRM on *BSD"},{"location":"README-kmsbsd/#sdl2-wscons-input-backend-features","text":"It is keymap-aware; it will work properly with different keymaps. It has mouse support. Accent input is supported. Compose keys are supported. AltGr and Meta Shift keys work as intended.","title":"SDL2 WSCONS input backend features"},{"location":"README-kmsbsd/#partially-working-or-no-input-on-openbsdnetbsd","text":"The WSCONS input backend needs read/write access to the /dev/wskbd* devices, without which it will not work properly. /dev/wsmouse must also be read/write accessible, otherwise mouse input will not work.","title":"Partially working or no input on OpenBSD/NetBSD."},{"location":"README-kmsbsd/#partially-working-or-no-input-on-freebsd","text":"The evdev devices are only accessible to the root user by default. Edit devfs rules to allow access to such devices. The /dev/kbd* devices are also only accessible to the root user by default. Edit devfs rules to allow access to such devices.","title":"Partially working or no input on FreeBSD."},{"location":"README-linux/","text":"Linux By default SDL will only link against glibc, the rest of the features will be enabled dynamically at runtime depending on the available features on the target system. So, for example if you built SDL with Xinerama support and the target system does not have the Xinerama libraries installed, it will be disabled at runtime, and you won't get a missing library error, at least with the default configuration parameters. Build Dependencies Ubuntu 20.04, all available features enabled: sudo apt-get install build-essential git make cmake autoconf automake \\ libtool pkg-config libasound2-dev libpulse-dev libaudio-dev libjack-dev \\ libx11-dev libxext-dev libxrandr-dev libxcursor-dev libxi-dev \\ libxinerama-dev libxxf86vm-dev libxss-dev libgl1-mesa-dev libdbus-1-dev \\ libudev-dev libgles2-mesa-dev libegl1-mesa-dev libibus-1.0-dev \\ fcitx-libs-dev libsamplerate0-dev libsndio-dev libwayland-dev \\ libxkbcommon-dev libdrm-dev libgbm-dev NOTES: - This includes all the audio targets except arts and esd, because Ubuntu (and/or Debian) pulled their packages, but in theory SDL still supports them. - libsamplerate0-dev lets SDL optionally link to libresamplerate at runtime for higher-quality audio resampling. SDL will work without it if the library is missing, so it's safe to build in support even if the end user doesn't have this library installed. - DirectFB isn't included because the configure script (currently) fails to find it at all. You can do \"sudo apt-get install libdirectfb-dev\" and fix the configure script to include DirectFB support. Send patches. :) Joystick does not work If you compiled or are using a version of SDL with udev support (and you should!) there's a few issues that may cause SDL to fail to detect your joystick. To debug this, start by installing the evtest utility. On Ubuntu/Debian: sudo apt-get install evtest Then run: sudo evtest You'll hopefully see your joystick listed along with a name like \"/dev/input/eventXX\" Now run: cat /dev/input/event/XX If you get a permission error, you need to set a udev rule to change the mode of your device (see below) Also, try: sudo udevadm info --query=all --name=input/eventXX If you see a line stating ID_INPUT_JOYSTICK=1, great, if you don't see it, you need to set up an udev rule to force this variable. A combined rule for the Saitek Pro Flight Rudder Pedals to fix both issues looks like: SUBSYSTEM==\"input\", ATTRS{idProduct}==\"0763\", ATTRS{idVendor}==\"06a3\", MODE=\"0666\", ENV{ID_INPUT_JOYSTICK}=\"1\" SUBSYSTEM==\"input\", ATTRS{idProduct}==\"0764\", ATTRS{idVendor}==\"06a3\", MODE=\"0666\", ENV{ID_INPUT_JOYSTICK}=\"1\" You can set up similar rules for your device by changing the values listed in idProduct and idVendor. To obtain these values, try: sudo udevadm info -a --name=input/eventXX | grep idVendor sudo udevadm info -a --name=input/eventXX | grep idProduct If multiple values come up for each of these, the one you want is the first one of each. On other systems which ship with an older udev (such as CentOS), you may need to set up a rule such as: SUBSYSTEM==\"input\", ENV{ID_CLASS}==\"joystick\", ENV{ID_INPUT_JOYSTICK}=\"1\"","title":"Linux"},{"location":"README-linux/#linux","text":"By default SDL will only link against glibc, the rest of the features will be enabled dynamically at runtime depending on the available features on the target system. So, for example if you built SDL with Xinerama support and the target system does not have the Xinerama libraries installed, it will be disabled at runtime, and you won't get a missing library error, at least with the default configuration parameters.","title":"Linux"},{"location":"README-linux/#build-dependencies","text":"Ubuntu 20.04, all available features enabled: sudo apt-get install build-essential git make cmake autoconf automake \\ libtool pkg-config libasound2-dev libpulse-dev libaudio-dev libjack-dev \\ libx11-dev libxext-dev libxrandr-dev libxcursor-dev libxi-dev \\ libxinerama-dev libxxf86vm-dev libxss-dev libgl1-mesa-dev libdbus-1-dev \\ libudev-dev libgles2-mesa-dev libegl1-mesa-dev libibus-1.0-dev \\ fcitx-libs-dev libsamplerate0-dev libsndio-dev libwayland-dev \\ libxkbcommon-dev libdrm-dev libgbm-dev NOTES: - This includes all the audio targets except arts and esd, because Ubuntu (and/or Debian) pulled their packages, but in theory SDL still supports them. - libsamplerate0-dev lets SDL optionally link to libresamplerate at runtime for higher-quality audio resampling. SDL will work without it if the library is missing, so it's safe to build in support even if the end user doesn't have this library installed. - DirectFB isn't included because the configure script (currently) fails to find it at all. You can do \"sudo apt-get install libdirectfb-dev\" and fix the configure script to include DirectFB support. Send patches. :)","title":"Build Dependencies"},{"location":"README-linux/#joystick-does-not-work","text":"If you compiled or are using a version of SDL with udev support (and you should!) there's a few issues that may cause SDL to fail to detect your joystick. To debug this, start by installing the evtest utility. On Ubuntu/Debian: sudo apt-get install evtest Then run: sudo evtest You'll hopefully see your joystick listed along with a name like \"/dev/input/eventXX\" Now run: cat /dev/input/event/XX If you get a permission error, you need to set a udev rule to change the mode of your device (see below) Also, try: sudo udevadm info --query=all --name=input/eventXX If you see a line stating ID_INPUT_JOYSTICK=1, great, if you don't see it, you need to set up an udev rule to force this variable. A combined rule for the Saitek Pro Flight Rudder Pedals to fix both issues looks like: SUBSYSTEM==\"input\", ATTRS{idProduct}==\"0763\", ATTRS{idVendor}==\"06a3\", MODE=\"0666\", ENV{ID_INPUT_JOYSTICK}=\"1\" SUBSYSTEM==\"input\", ATTRS{idProduct}==\"0764\", ATTRS{idVendor}==\"06a3\", MODE=\"0666\", ENV{ID_INPUT_JOYSTICK}=\"1\" You can set up similar rules for your device by changing the values listed in idProduct and idVendor. To obtain these values, try: sudo udevadm info -a --name=input/eventXX | grep idVendor sudo udevadm info -a --name=input/eventXX | grep idProduct If multiple values come up for each of these, the one you want is the first one of each. On other systems which ship with an older udev (such as CentOS), you may need to set up a rule such as: SUBSYSTEM==\"input\", ENV{ID_CLASS}==\"joystick\", ENV{ID_INPUT_JOYSTICK}=\"1\"","title":"Joystick does not work"},{"location":"README-macosx/","text":"Mac OS X These instructions are for people using Apple's Mac OS X (pronounced \"ten\"). From the developer's point of view, OS X is a sort of hybrid Mac and Unix system, and you have the option of using either traditional command line tools or Apple's IDE Xcode. Command Line Build To build SDL using the command line, use the standard configure and make process: ./configure make sudo make install You can also build SDL as a Universal library (a single binary for both 32-bit and 64-bit Intel architectures), on Mac OS X 10.7 and newer, by using the gcc-fat.sh script in build-scripts: mkdir mybuild cd mybuild CC=$PWD/../build-scripts/gcc-fat.sh CXX=$PWD/../build-scripts/g++-fat.sh ../configure make sudo make install This script builds SDL with 10.5 ABI compatibility on i386 and 10.6 ABI compatibility on x86_64 architectures. For best compatibility you should compile your application the same way. Please note that building SDL requires at least Xcode 4.6 and the 10.7 SDK (even if you target back to 10.5 systems). PowerPC support for Mac OS X has been officially dropped as of SDL 2.0.2. To use the library once it's built, you essential have two possibilities: use the traditional autoconf/automake/make method, or use Xcode. ============================================================================== Caveats for using SDL with Mac OS X ============================================================================== Some things you have to be aware of when using SDL on Mac OS X: If you register your own NSApplicationDelegate (using [NSApp setDelegate:]), SDL will not register its own. This means that SDL will not terminate using SDL_Quit if it receives a termination request, it will terminate like a normal app, and it will not send a SDL_DROPFILE when you request to open a file with the app. To solve these issues, put the following code in your NSApplicationDelegate implementation: (NSApplicationTerminateReply)applicationShouldTerminate:(NSApplication *)sender { if (SDL_GetEventState(SDL_QUIT) == SDL_ENABLE) { SDL_Event event; event.type = SDL_QUIT; SDL_PushEvent(&event); } return NSTerminateCancel; } (BOOL)application:(NSApplication )theApplication openFile:(NSString )filename { if (SDL_GetEventState(SDL_DROPFILE) == SDL_ENABLE) { SDL_Event event; event.type = SDL_DROPFILE; event.drop.file = SDL_strdup([filename UTF8String]); return (SDL_PushEvent(&event) > 0); } return NO; } ============================================================================== Using the Simple DirectMedia Layer with a traditional Makefile ============================================================================== An existing autoconf/automake build system for your SDL app has good chances to work almost unchanged on OS X. However, to produce a \"real\" Mac OS X binary that you can distribute to users, you need to put the generated binary into a so called \"bundle\", which basically is a fancy folder with a name like \"MyCoolGame.app\". To get this build automatically, add something like the following rule to your Makefile.am: bundle_contents = APP_NAME.app/Contents APP_NAME_bundle: EXE_NAME mkdir -p $(bundle_contents)/MacOS mkdir -p $(bundle_contents)/Resources echo \"APPL????\" > $(bundle_contents)/PkgInfo $(INSTALL_PROGRAM) $< $(bundle_contents)/MacOS/ You should replace EXE_NAME with the name of the executable. APP_NAME is what will be visible to the user in the Finder. Usually it will be the same as EXE_NAME but capitalized. E.g. if EXE_NAME is \"testgame\" then APP_NAME usually is \"TestGame\". You might also want to use @PACKAGE@ to use the package name as specified in your configure.ac file. If your project builds more than one application, you will have to do a bit more. For each of your target applications, you need a separate rule. If you want the created bundles to be installed, you may want to add this rule to your Makefile.am: install-exec-hook: APP_NAME_bundle rm -rf $(DESTDIR)$(prefix)/Applications/APP_NAME.app mkdir -p $(DESTDIR)$(prefix)/Applications/ cp -r $< /$(DESTDIR)$(prefix)Applications/ This rule takes the Bundle created by the rule from step 3 and installs them into \"$(DESTDIR)$(prefix)/Applications/\". Again, if you want to install multiple applications, you will have to augment the make rule accordingly. But beware! That is only part of the story! With the above, you end up with a bare bone .app bundle, which is double clickable from the Finder. But there are some more things you should do before shipping your product... 1) The bundle right now probably is dynamically linked against SDL. That means that when you copy it to another computer, it will not run , unless you also install SDL on that other computer. A good solution for this dilemma is to static link against SDL. On OS X, you can achieve that by linking against the libraries listed by sdl-config --static-libs instead of those listed by sdl-config --libs Depending on how exactly SDL is integrated into your build systems, the way to achieve that varies, so I won't describe it here in detail 2) Add an 'Info.plist' to your application. That is a special XML file which contains some meta-information about your application (like some copyright information, the version of your app, the name of an optional icon file, and other things). Part of that information is displayed by the Finder when you click on the .app, or if you look at the \"Get Info\" window. More information about Info.plist files can be found on Apple's homepage. As a final remark, let me add that I use some of the techniques (and some variations of them) in Exult and ScummVM; both are available in source on the net, so feel free to take a peek at them for inspiration! ============================================================================== Using the Simple DirectMedia Layer with Xcode ============================================================================== These instructions are for using Apple's Xcode IDE to build SDL applications. First steps The first thing to do is to unpack the Xcode.tar.gz archive in the top level SDL directory (where the Xcode.tar.gz archive resides). Because Stuffit Expander will unpack the archive into a subdirectory, you should unpack the archive manually from the command line: cd [path_to_SDL_source] tar zxf Xcode.tar.gz This will create a new folder called Xcode, which you can browse normally from the Finder. Building the Framework The SDL Library is packaged as a framework bundle, an organized relocatable folder hierarchy of executable code, interface headers, and additional resources. For practical purposes, you can think of a framework as a more user and system-friendly shared library, whose library file behaves more or less like a standard UNIX shared library. To build the framework, simply open the framework project and build it. By default, the framework bundle \"SDL.framework\" is installed in /Library/Frameworks. Therefore, the testers and project stationary expect it to be located there. However, it will function the same in any of the following locations: ~/Library/Frameworks /Local/Library/Frameworks /System/Library/Frameworks Build Options There are two \"Build Styles\" (See the \"Targets\" tab) for SDL. \"Deployment\" should be used if you aren't tweaking the SDL library. \"Development\" should be used to debug SDL apps or the library itself. Building the Testers Open the SDLTest project and build away! Using the Project Stationary Copy the stationary to the indicated folders to access it from the \"New Project\" and \"Add target\" menus. What could be easier? Setting up a new project by hand Some of you won't want to use the Stationary so I'll give some tips: Create a new \"Cocoa Application\" Add src/main/macosx/SDLMain.m , .h and .nib to your project Remove \"main.c\" from your project Remove \"MainMenu.nib\" from your project Add \"$(HOME)/Library/Frameworks/SDL.framework/Headers\" to include path Add \"$(HOME)/Library/Frameworks\" to the frameworks search path Add \"-framework SDL -framework Foundation -framework AppKit\" to \"OTHER_LDFLAGS\" Set the \"Main Nib File\" under \"Application Settings\" to \"SDLMain.nib\" Add your files Clean and build Building from command line Use pbxbuild in the same directory as your .pbproj file Running your app You can send command line args to your app by either invoking it from the command line (in *.app/Contents/MacOS) or by entering them in the \"Executables\" panel of the target settings. Implementation Notes Some things that may be of interest about how it all works... Working directory As defined in the SDL_main.m file, the working directory of your SDL app is by default set to its parent. You may wish to change this to better suit your needs. You have a Cocoa App! Your SDL app is essentially a Cocoa application. When your app starts up and the libraries finish loading, a Cocoa procedure is called, which sets up the working directory and calls your main() method. You are free to modify your Cocoa app with generally no consequence to SDL. You cannot, however, easily change the SDL window itself. Functionality may be added in the future to help this. Known bugs are listed in the file \"BUGS.txt\".","title":"OS X"},{"location":"README-macosx/#mac-os-x","text":"These instructions are for people using Apple's Mac OS X (pronounced \"ten\"). From the developer's point of view, OS X is a sort of hybrid Mac and Unix system, and you have the option of using either traditional command line tools or Apple's IDE Xcode.","title":"Mac OS X"},{"location":"README-macosx/#command-line-build","text":"To build SDL using the command line, use the standard configure and make process: ./configure make sudo make install You can also build SDL as a Universal library (a single binary for both 32-bit and 64-bit Intel architectures), on Mac OS X 10.7 and newer, by using the gcc-fat.sh script in build-scripts: mkdir mybuild cd mybuild CC=$PWD/../build-scripts/gcc-fat.sh CXX=$PWD/../build-scripts/g++-fat.sh ../configure make sudo make install This script builds SDL with 10.5 ABI compatibility on i386 and 10.6 ABI compatibility on x86_64 architectures. For best compatibility you should compile your application the same way. Please note that building SDL requires at least Xcode 4.6 and the 10.7 SDK (even if you target back to 10.5 systems). PowerPC support for Mac OS X has been officially dropped as of SDL 2.0.2. To use the library once it's built, you essential have two possibilities: use the traditional autoconf/automake/make method, or use Xcode. ============================================================================== Caveats for using SDL with Mac OS X ============================================================================== Some things you have to be aware of when using SDL on Mac OS X: If you register your own NSApplicationDelegate (using [NSApp setDelegate:]), SDL will not register its own. This means that SDL will not terminate using SDL_Quit if it receives a termination request, it will terminate like a normal app, and it will not send a SDL_DROPFILE when you request to open a file with the app. To solve these issues, put the following code in your NSApplicationDelegate implementation: (NSApplicationTerminateReply)applicationShouldTerminate:(NSApplication *)sender { if (SDL_GetEventState(SDL_QUIT) == SDL_ENABLE) { SDL_Event event; event.type = SDL_QUIT; SDL_PushEvent(&event); } return NSTerminateCancel; } (BOOL)application:(NSApplication )theApplication openFile:(NSString )filename { if (SDL_GetEventState(SDL_DROPFILE) == SDL_ENABLE) { SDL_Event event; event.type = SDL_DROPFILE; event.drop.file = SDL_strdup([filename UTF8String]); return (SDL_PushEvent(&event) > 0); } return NO; } ============================================================================== Using the Simple DirectMedia Layer with a traditional Makefile ============================================================================== An existing autoconf/automake build system for your SDL app has good chances to work almost unchanged on OS X. However, to produce a \"real\" Mac OS X binary that you can distribute to users, you need to put the generated binary into a so called \"bundle\", which basically is a fancy folder with a name like \"MyCoolGame.app\". To get this build automatically, add something like the following rule to your Makefile.am: bundle_contents = APP_NAME.app/Contents APP_NAME_bundle: EXE_NAME mkdir -p $(bundle_contents)/MacOS mkdir -p $(bundle_contents)/Resources echo \"APPL????\" > $(bundle_contents)/PkgInfo $(INSTALL_PROGRAM) $< $(bundle_contents)/MacOS/ You should replace EXE_NAME with the name of the executable. APP_NAME is what will be visible to the user in the Finder. Usually it will be the same as EXE_NAME but capitalized. E.g. if EXE_NAME is \"testgame\" then APP_NAME usually is \"TestGame\". You might also want to use @PACKAGE@ to use the package name as specified in your configure.ac file. If your project builds more than one application, you will have to do a bit more. For each of your target applications, you need a separate rule. If you want the created bundles to be installed, you may want to add this rule to your Makefile.am: install-exec-hook: APP_NAME_bundle rm -rf $(DESTDIR)$(prefix)/Applications/APP_NAME.app mkdir -p $(DESTDIR)$(prefix)/Applications/ cp -r $< /$(DESTDIR)$(prefix)Applications/ This rule takes the Bundle created by the rule from step 3 and installs them into \"$(DESTDIR)$(prefix)/Applications/\". Again, if you want to install multiple applications, you will have to augment the make rule accordingly. But beware! That is only part of the story! With the above, you end up with a bare bone .app bundle, which is double clickable from the Finder. But there are some more things you should do before shipping your product... 1) The bundle right now probably is dynamically linked against SDL. That means that when you copy it to another computer, it will not run , unless you also install SDL on that other computer. A good solution for this dilemma is to static link against SDL. On OS X, you can achieve that by linking against the libraries listed by sdl-config --static-libs instead of those listed by sdl-config --libs Depending on how exactly SDL is integrated into your build systems, the way to achieve that varies, so I won't describe it here in detail 2) Add an 'Info.plist' to your application. That is a special XML file which contains some meta-information about your application (like some copyright information, the version of your app, the name of an optional icon file, and other things). Part of that information is displayed by the Finder when you click on the .app, or if you look at the \"Get Info\" window. More information about Info.plist files can be found on Apple's homepage. As a final remark, let me add that I use some of the techniques (and some variations of them) in Exult and ScummVM; both are available in source on the net, so feel free to take a peek at them for inspiration! ============================================================================== Using the Simple DirectMedia Layer with Xcode ============================================================================== These instructions are for using Apple's Xcode IDE to build SDL applications. First steps The first thing to do is to unpack the Xcode.tar.gz archive in the top level SDL directory (where the Xcode.tar.gz archive resides). Because Stuffit Expander will unpack the archive into a subdirectory, you should unpack the archive manually from the command line: cd [path_to_SDL_source] tar zxf Xcode.tar.gz This will create a new folder called Xcode, which you can browse normally from the Finder. Building the Framework The SDL Library is packaged as a framework bundle, an organized relocatable folder hierarchy of executable code, interface headers, and additional resources. For practical purposes, you can think of a framework as a more user and system-friendly shared library, whose library file behaves more or less like a standard UNIX shared library. To build the framework, simply open the framework project and build it. By default, the framework bundle \"SDL.framework\" is installed in /Library/Frameworks. Therefore, the testers and project stationary expect it to be located there. However, it will function the same in any of the following locations: ~/Library/Frameworks /Local/Library/Frameworks /System/Library/Frameworks Build Options There are two \"Build Styles\" (See the \"Targets\" tab) for SDL. \"Deployment\" should be used if you aren't tweaking the SDL library. \"Development\" should be used to debug SDL apps or the library itself. Building the Testers Open the SDLTest project and build away! Using the Project Stationary Copy the stationary to the indicated folders to access it from the \"New Project\" and \"Add target\" menus. What could be easier? Setting up a new project by hand Some of you won't want to use the Stationary so I'll give some tips: Create a new \"Cocoa Application\" Add src/main/macosx/SDLMain.m , .h and .nib to your project Remove \"main.c\" from your project Remove \"MainMenu.nib\" from your project Add \"$(HOME)/Library/Frameworks/SDL.framework/Headers\" to include path Add \"$(HOME)/Library/Frameworks\" to the frameworks search path Add \"-framework SDL -framework Foundation -framework AppKit\" to \"OTHER_LDFLAGS\" Set the \"Main Nib File\" under \"Application Settings\" to \"SDLMain.nib\" Add your files Clean and build Building from command line Use pbxbuild in the same directory as your .pbproj file Running your app You can send command line args to your app by either invoking it from the command line (in *.app/Contents/MacOS) or by entering them in the \"Executables\" panel of the target settings. Implementation Notes Some things that may be of interest about how it all works... Working directory As defined in the SDL_main.m file, the working directory of your SDL app is by default set to its parent. You may wish to change this to better suit your needs. You have a Cocoa App! Your SDL app is essentially a Cocoa application. When your app starts up and the libraries finish loading, a Cocoa procedure is called, which sets up the working directory and calls your main() method. You are free to modify your Cocoa app with generally no consequence to SDL. You cannot, however, easily change the SDL window itself. Functionality may be added in the future to help this. Known bugs are listed in the file \"BUGS.txt\".","title":"Command Line Build"},{"location":"README-nacl/","text":"Native Client Requirements: Native Client SDK (https://developer.chrome.com/native-client), (tested with Pepper version 33 or higher). The SDL backend for Chrome's Native Client has been tested only with the PNaCl toolchain, which generates binaries designed to run on ARM and x86_32/64 platforms. This does not mean it won't work with the other toolchains! ================================================================================ Building SDL for NaCl ================================================================================ Set up the right environment variables (see naclbuild.sh), then configure SDL with: configure --host=pnacl --prefix some/install/destination Then \"make\". As an example of how to create a deployable app a Makefile project is provided in test/nacl/Makefile, which includes some monkey patching of the common.mk file provided by NaCl, without which linking properly to SDL won't work (the search path can't be modified externally, so the linker won't find SDL's binaries unless you dump them into the SDK path, which is inconvenient). Also provided in test/nacl is the required support file, such as index.html, manifest.json, etc. SDL apps for NaCl run on a worker thread using the ppapi_simple infrastructure. This allows for blocking calls on all the relevant systems (OpenGL ES, filesystem), hiding the asynchronous nature of the browser behind the scenes...which is not the same as making it disappear! ================================================================================ Running tests ================================================================================ Due to the nature of NaCl programs, building and running SDL tests is not as straightforward as one would hope. The script naclbuild.sh in build-scripts automates the process and should serve as a guide for users of SDL trying to build their own applications. Basic usage: ./naclbuild.sh path/to/pepper/toolchain (i.e. ~/naclsdk/pepper_35) This will build testgles2.c by default. If you want to build a different test, for example testrendercopyex.c: SOURCES=~/sdl/SDL/test/testrendercopyex.c ./naclbuild.sh ~/naclsdk/pepper_35 Once the build finishes, you have to serve the contents with a web server (the script will give you instructions on how to do that with Python). ================================================================================ RWops and nacl_io ================================================================================ SDL_RWops work transparently with nacl_io. Two functions control the mount points: int mount(const char* source, const char* target, const char* filesystemtype, unsigned long mountflags, const void *data); int umount(const char *target); For convenience, SDL will by default mount an httpfs tree at / before calling the app's main function. Such setting can be overridden by calling: umount(\"/\"); And then mounting a different filesystem at / It's important to consider that the asynchronous nature of file operations on a browser is hidden from the application, effectively providing the developer with a set of blocking file operations just like you get in a regular desktop environment, which eases the job of porting to Native Client, but also introduces a set of challenges of its own, in particular when big file sizes and slow connections are involved. For more information on how nacl_io and mount points work, see: https://developer.chrome.com/native-client/devguide/coding/nacl_io https://src.chromium.org/chrome/trunk/src/native_client_sdk/src/libraries/nacl_io/nacl_io.h To be able to save into the directory \"/save/\" (like backup of game) : mount(\"\", \"/save\", \"html5fs\", 0, \"type=PERSISTENT\"); And add to manifest.json : \"permissions\": [ \"unlimitedStorage\" ] ================================================================================ TODO - Known Issues ================================================================================ * Testing of all systems with a real application (something other than SDL's tests) * Key events don't seem to work properly","title":"NativeClient"},{"location":"README-nacl/#native-client","text":"Requirements: Native Client SDK (https://developer.chrome.com/native-client), (tested with Pepper version 33 or higher). The SDL backend for Chrome's Native Client has been tested only with the PNaCl toolchain, which generates binaries designed to run on ARM and x86_32/64 platforms. This does not mean it won't work with the other toolchains! ================================================================================ Building SDL for NaCl ================================================================================ Set up the right environment variables (see naclbuild.sh), then configure SDL with: configure --host=pnacl --prefix some/install/destination Then \"make\". As an example of how to create a deployable app a Makefile project is provided in test/nacl/Makefile, which includes some monkey patching of the common.mk file provided by NaCl, without which linking properly to SDL won't work (the search path can't be modified externally, so the linker won't find SDL's binaries unless you dump them into the SDK path, which is inconvenient). Also provided in test/nacl is the required support file, such as index.html, manifest.json, etc. SDL apps for NaCl run on a worker thread using the ppapi_simple infrastructure. This allows for blocking calls on all the relevant systems (OpenGL ES, filesystem), hiding the asynchronous nature of the browser behind the scenes...which is not the same as making it disappear! ================================================================================ Running tests ================================================================================ Due to the nature of NaCl programs, building and running SDL tests is not as straightforward as one would hope. The script naclbuild.sh in build-scripts automates the process and should serve as a guide for users of SDL trying to build their own applications. Basic usage: ./naclbuild.sh path/to/pepper/toolchain (i.e. ~/naclsdk/pepper_35) This will build testgles2.c by default. If you want to build a different test, for example testrendercopyex.c: SOURCES=~/sdl/SDL/test/testrendercopyex.c ./naclbuild.sh ~/naclsdk/pepper_35 Once the build finishes, you have to serve the contents with a web server (the script will give you instructions on how to do that with Python). ================================================================================ RWops and nacl_io ================================================================================ SDL_RWops work transparently with nacl_io. Two functions control the mount points: int mount(const char* source, const char* target, const char* filesystemtype, unsigned long mountflags, const void *data); int umount(const char *target); For convenience, SDL will by default mount an httpfs tree at / before calling the app's main function. Such setting can be overridden by calling: umount(\"/\"); And then mounting a different filesystem at / It's important to consider that the asynchronous nature of file operations on a browser is hidden from the application, effectively providing the developer with a set of blocking file operations just like you get in a regular desktop environment, which eases the job of porting to Native Client, but also introduces a set of challenges of its own, in particular when big file sizes and slow connections are involved. For more information on how nacl_io and mount points work, see: https://developer.chrome.com/native-client/devguide/coding/nacl_io https://src.chromium.org/chrome/trunk/src/native_client_sdk/src/libraries/nacl_io/nacl_io.h To be able to save into the directory \"/save/\" (like backup of game) : mount(\"\", \"/save\", \"html5fs\", 0, \"type=PERSISTENT\"); And add to manifest.json : \"permissions\": [ \"unlimitedStorage\" ] ================================================================================ TODO - Known Issues ================================================================================ * Testing of all systems with a real application (something other than SDL's tests) * Key events don't seem to work properly","title":"Native Client"},{"location":"README-os2/","text":"Simple DirectMedia Layer 2 for OS/2 & eComStation SDL port for OS/2, authored by Andrey Vasilkin digi@os2.snc.ru , 2016 OpenGL, joystick and audio capture not supported by this port. Additional environment variables (optional) for OS/2 version: SDL_AUDIO_SHARE Values: 0 or 1, default is 0 Initializes the device as shareable or exclusively acquired. SDL_VIDEODRIVER Values: DIVE or VMAN, default is DIVE Use video subsystem: Direct interface video extensions (DIVE) or Video Manager (VMAN). You may significantly increase video output speed with OS4 kernel and patched files vman.dll and dive.dll or with latest versions of ACPI support and video driver Panorama. Latest versions of OS/4 kernel: http://gus.biysk.ru/os4/ (Info: https://www.os2world.com/wiki/index.php/Phoenix_OS/4) Patched files vman.dll and dive.dll: http://gus.biysk.ru/os4/test/pached_dll/PATCHED_DLL.RAR Compiling: Open Watcom 1.9 or newer is tested. For the new Open Watcom V2 fork, see: https://github.com/open-watcom/ and https://open-watcom.github.io WATCOM ervironment variable must to be set to the Open Watcom install directory. To compile, run: wmake -f Makefile.os2 Installing: eComStation: If you have previously installed SDL2, make a Backup copy of SDL2.dll located in D:\\ecs\\dll (where D: is disk on which installed eComStation). Stop all programs running with SDL2. Copy SDL2.dll to D:\\ecs\\dll OS/2: Copy SDL2.dll to any directory on your LIBPATH. If you have a previous version installed, close all SDL2 applications before replacing the old copy. Also make sure that any other older versions of DLLs are removed from your system.","title":"OS2"},{"location":"README-os2/#simple-directmedia-layer-2-for-os2-ecomstation","text":"SDL port for OS/2, authored by Andrey Vasilkin digi@os2.snc.ru , 2016 OpenGL, joystick and audio capture not supported by this port. Additional environment variables (optional) for OS/2 version: SDL_AUDIO_SHARE Values: 0 or 1, default is 0 Initializes the device as shareable or exclusively acquired. SDL_VIDEODRIVER Values: DIVE or VMAN, default is DIVE Use video subsystem: Direct interface video extensions (DIVE) or Video Manager (VMAN). You may significantly increase video output speed with OS4 kernel and patched files vman.dll and dive.dll or with latest versions of ACPI support and video driver Panorama. Latest versions of OS/4 kernel: http://gus.biysk.ru/os4/ (Info: https://www.os2world.com/wiki/index.php/Phoenix_OS/4) Patched files vman.dll and dive.dll: http://gus.biysk.ru/os4/test/pached_dll/PATCHED_DLL.RAR","title":"Simple DirectMedia Layer 2 for OS/2 &amp; eComStation"},{"location":"README-os2/#compiling","text":"Open Watcom 1.9 or newer is tested. For the new Open Watcom V2 fork, see: https://github.com/open-watcom/ and https://open-watcom.github.io WATCOM ervironment variable must to be set to the Open Watcom install directory. To compile, run: wmake -f Makefile.os2","title":"Compiling:"},{"location":"README-os2/#installing","text":"eComStation: If you have previously installed SDL2, make a Backup copy of SDL2.dll located in D:\\ecs\\dll (where D: is disk on which installed eComStation). Stop all programs running with SDL2. Copy SDL2.dll to D:\\ecs\\dll OS/2: Copy SDL2.dll to any directory on your LIBPATH. If you have a previous version installed, close all SDL2 applications before replacing the old copy. Also make sure that any other older versions of DLLs are removed from your system.","title":"Installing:"},{"location":"README-pandora/","text":"Pandora ( http://openpandora.org/ ) - A pandora specific video driver was written to allow SDL 2.0 with OpenGL ES support to work on the pandora under the framebuffer. This driver do not have input support for now, so if you use it you will have to add your own control code. The video driver name is \"pandora\" so if you have problem running it from the framebuffer, try to set the following variable before starting your application : \"export SDL_VIDEODRIVER=pandora\" OpenGL ES support was added to the x11 driver, so it's working like the normal x11 driver one with OpenGLX support, with SDL input event's etc.. David Carr\u00e9 (Cpasjuste) cpasjuste@gmail.com","title":"Pandora"},{"location":"README-pandora/#pandora","text":"( http://openpandora.org/ ) - A pandora specific video driver was written to allow SDL 2.0 with OpenGL ES support to work on the pandora under the framebuffer. This driver do not have input support for now, so if you use it you will have to add your own control code. The video driver name is \"pandora\" so if you have problem running it from the framebuffer, try to set the following variable before starting your application : \"export SDL_VIDEODRIVER=pandora\" OpenGL ES support was added to the x11 driver, so it's working like the normal x11 driver one with OpenGLX support, with SDL input event's etc.. David Carr\u00e9 (Cpasjuste) cpasjuste@gmail.com","title":"Pandora"},{"location":"README-platforms/","text":"Platforms We maintain the list of supported platforms on our wiki now, and how to build and install SDL for those platforms: https://github.com/libsdl-org/SDL/wiki/Installation","title":"Overview"},{"location":"README-platforms/#platforms","text":"We maintain the list of supported platforms on our wiki now, and how to build and install SDL for those platforms: https://github.com/libsdl-org/SDL/wiki/Installation","title":"Platforms"},{"location":"README-porting/","text":"Porting Porting To A New Platform The first thing you have to do when porting to a new platform, is look at include/SDL_platform.h and create an entry there for your operating system. The standard format is \" PLATFORM \", where PLATFORM is the name of the OS. Ideally SDL_platform.h will be able to auto-detect the system it's building on based on C preprocessor symbols. There are two basic ways of building SDL at the moment: The \"UNIX\" way: ./configure; make; make install If you have a GNUish system, then you might try this. Edit configure.ac, take a look at the large section labelled: \"Set up the configuration based on the host platform!\" Add a section for your platform, and then re-run autogen.sh and build! Using an IDE: If you're using an IDE or other non-configure build system, you'll probably want to create a custom SDL_config.h for your platform. Edit SDL_config.h, add a section for your platform, and create a custom SDL_config_{platform}.h, based on SDL_config_minimal.h and SDL_config.h.in Add the top level include directory to the header search path, and then add the following sources to the project: src/*.c src/atomic/*.c src/audio/*.c src/cpuinfo/*.c src/events/*.c src/file/*.c src/haptic/*.c src/joystick/*.c src/power/*.c src/render/*.c src/render/software/*.c src/stdlib/*.c src/thread/*.c src/timer/*.c src/video/*.c src/audio/disk/*.c src/audio/dummy/*.c src/filesystem/dummy/*.c src/video/dummy/*.c src/haptic/dummy/*.c src/joystick/dummy/*.c src/main/dummy/*.c src/thread/generic/*.c src/timer/dummy/*.c src/loadso/dummy/*.c Once you have a working library without any drivers, you can go back to each of the major subsystems and start implementing drivers for your platform. If you have any questions, don't hesitate to ask on the SDL mailing list: http://www.libsdl.org/mailing-list.php Enjoy! Sam Lantinga (slouken@libsdl.org)","title":"Porting"},{"location":"README-porting/#porting","text":"Porting To A New Platform The first thing you have to do when porting to a new platform, is look at include/SDL_platform.h and create an entry there for your operating system. The standard format is \" PLATFORM \", where PLATFORM is the name of the OS. Ideally SDL_platform.h will be able to auto-detect the system it's building on based on C preprocessor symbols. There are two basic ways of building SDL at the moment: The \"UNIX\" way: ./configure; make; make install If you have a GNUish system, then you might try this. Edit configure.ac, take a look at the large section labelled: \"Set up the configuration based on the host platform!\" Add a section for your platform, and then re-run autogen.sh and build! Using an IDE: If you're using an IDE or other non-configure build system, you'll probably want to create a custom SDL_config.h for your platform. Edit SDL_config.h, add a section for your platform, and create a custom SDL_config_{platform}.h, based on SDL_config_minimal.h and SDL_config.h.in Add the top level include directory to the header search path, and then add the following sources to the project: src/*.c src/atomic/*.c src/audio/*.c src/cpuinfo/*.c src/events/*.c src/file/*.c src/haptic/*.c src/joystick/*.c src/power/*.c src/render/*.c src/render/software/*.c src/stdlib/*.c src/thread/*.c src/timer/*.c src/video/*.c src/audio/disk/*.c src/audio/dummy/*.c src/filesystem/dummy/*.c src/video/dummy/*.c src/haptic/dummy/*.c src/joystick/dummy/*.c src/main/dummy/*.c src/thread/generic/*.c src/timer/dummy/*.c src/loadso/dummy/*.c Once you have a working library without any drivers, you can go back to each of the major subsystems and start implementing drivers for your platform. If you have any questions, don't hesitate to ask on the SDL mailing list: http://www.libsdl.org/mailing-list.php Enjoy! Sam Lantinga (slouken@libsdl.org)","title":"Porting"},{"location":"README-psp/","text":"PSP SDL port for the Sony PSP contributed by Captian Lex Credit to Marcus R.Brown,Jim Paris,Matthew H for the original SDL 1.2 for PSP Geecko for his PSP GU lib \"Glib2d\" Building To build for the PSP, make sure psp-config is in the path and run: make -f Makefile.psp To Do PSP Screen Keyboard","title":"PSP"},{"location":"README-psp/#psp","text":"SDL port for the Sony PSP contributed by Captian Lex Credit to Marcus R.Brown,Jim Paris,Matthew H for the original SDL 1.2 for PSP Geecko for his PSP GU lib \"Glib2d\"","title":"PSP"},{"location":"README-psp/#building","text":"To build for the PSP, make sure psp-config is in the path and run: make -f Makefile.psp","title":"Building"},{"location":"README-psp/#to-do","text":"PSP Screen Keyboard","title":"To Do"},{"location":"README-raspberrypi/","text":"Raspberry Pi Requirements: Raspbian (other Linux distros may work as well). ================================================================================ Features ================================================================================ Works without X11 Hardware accelerated OpenGL ES 2.x Sound via ALSA Input (mouse/keyboard/joystick) via EVDEV Hotplugging of input devices via UDEV ================================================================================ Raspbian Build Dependencies ================================================================================ sudo apt-get install libudev-dev libasound2-dev libdbus-1-dev You also need the VideoCore binary stuff that ships in /opt/vc for EGL and OpenGL ES 2.x, it usually comes pre-installed, but in any case: sudo apt-get install libraspberrypi0 libraspberrypi-bin libraspberrypi-dev ================================================================================ NEON ================================================================================ If your Pi has NEON support, make sure you add -mfpu=neon to your CFLAGS so that SDL will select some otherwise-disabled highly-optimized code. The original Pi units don't have NEON, the Pi2 probably does, and the Pi3 definitely does. ================================================================================ Cross compiling from x86 Linux ================================================================================ To cross compile SDL for Raspbian from your desktop machine, you'll need a Raspbian system root and the cross compilation tools. We'll assume these tools will be placed in /opt/rpi-tools sudo git clone --depth 1 https://github.com/raspberrypi/tools /opt/rpi-tools You'll also need a Raspbian binary image. Get it from: http://downloads.raspberrypi.org/raspbian_latest After unzipping, you'll get file with a name like: \" -wheezy-raspbian.img\" Let's assume the sysroot will be built in /opt/rpi-sysroot. export SYSROOT=/opt/rpi-sysroot sudo kpartx -a -v <path_to_raspbian_image>.img sudo mount -o loop /dev/mapper/loop0p2 /mnt sudo cp -r /mnt $SYSROOT sudo apt-get install qemu binfmt-support qemu-user-static sudo cp /usr/bin/qemu-arm-static $SYSROOT/usr/bin sudo mount --bind /dev $SYSROOT/dev sudo mount --bind /proc $SYSROOT/proc sudo mount --bind /sys $SYSROOT/sys Now, before chrooting into the ARM sysroot, you'll need to apply a workaround, edit $SYSROOT/etc/ld.so.preload and comment out all lines in it. sudo chroot $SYSROOT apt-get install libudev-dev libasound2-dev libdbus-1-dev libraspberrypi0 libraspberrypi-bin libraspberrypi-dev libx11-dev libxext-dev libxrandr-dev libxcursor-dev libxi-dev libxinerama-dev libxxf86vm-dev libxss-dev exit sudo umount $SYSROOT/dev sudo umount $SYSROOT/proc sudo umount $SYSROOT/sys sudo umount /mnt There's one more fix required, as the libdl.so symlink uses an absolute path which doesn't quite work in our setup. sudo rm -rf $SYSROOT/usr/lib/arm-linux-gnueabihf/libdl.so sudo ln -s ../../../lib/arm-linux-gnueabihf/libdl.so.2 $SYSROOT/usr/lib/arm-linux-gnueabihf/libdl.so The final step is compiling SDL itself. export CC=\"/opt/rpi-tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian/bin/arm-linux-gnueabihf-gcc --sysroot=$SYSROOT -I$SYSROOT/opt/vc/include -I$SYSROOT/usr/include -I$SYSROOT/opt/vc/include/interface/vcos/pthreads -I$SYSROOT/opt/vc/include/interface/vmcs_host/linux\" cd <SDL SOURCE> mkdir -p build;cd build LDFLAGS=\"-L$SYSROOT/opt/vc/lib\" ../configure --with-sysroot=$SYSROOT --host=arm-raspberry-linux-gnueabihf --prefix=$PWD/rpi-sdl2-installed --disable-pulseaudio --disable-esd make make install To be able to deploy this to /usr/local in the Raspbian system you need to fix up a few paths: perl -w -pi -e \"s#$PWD/rpi-sdl2-installed#/usr/local#g;\" ./rpi-sdl2-installed/lib/libSDL2.la ./rpi-sdl2-installed/lib/pkgconfig/sdl2.pc ./rpi-sdl2-installed/bin/sdl2-config ================================================================================ Apps don't work or poor video/audio performance ================================================================================ If you get sound problems, buffer underruns, etc, run \"sudo rpi-update\" to update the RPi's firmware. Note that doing so will fix these problems, but it will also render the CMA - Dynamic Memory Split functionality useless. Also, by default the Raspbian distro configures the GPU RAM at 64MB, this is too low in general, specially if a 1080p TV is hooked up. See here how to configure this setting: http://elinux.org/RPiconfig Using a fixed gpu_mem=128 is the best option (specially if you updated the firmware, using CMA probably won't work, at least it's the current case). ================================================================================ No input ================================================================================ Make sure you belong to the \"input\" group. sudo usermod -aG input `whoami` ================================================================================ No HDMI Audio ================================================================================ If you notice that ALSA works but there's no audio over HDMI, try adding: hdmi_drive=2 to your config.txt file and reboot. Reference: http://www.raspberrypi.org/phpBB3/viewtopic.php?t=5062 ================================================================================ Text Input API support ================================================================================ The Text Input API is supported, with translation of scan codes done via the kernel symbol tables. For this to work, SDL needs access to a valid console. If you notice there's no SDL_TEXTINPUT message being emitted, double check that your app has read access to one of the following: /proc/self/fd/0 /dev/tty /dev/tty[0...6] /dev/vc/0 /dev/console This is usually not a problem if you run from the physical terminal (as opposed to running from a pseudo terminal, such as via SSH). If running from a PTS, a quick workaround is to run your app as root or add yourself to the tty group, then re-login to the system. sudo usermod -aG tty `whoami` The keyboard layout used by SDL is the same as the one the kernel uses. To configure the layout on Raspbian: sudo dpkg-reconfigure keyboard-configuration To configure the locale, which controls which keys are interpreted as letters, this determining the CAPS LOCK behavior: sudo dpkg-reconfigure locales ================================================================================ OpenGL problems ================================================================================ If you have desktop OpenGL headers installed at build time in your RPi or cross compilation environment, support for it will be built in. However, the chipset does not actually have support for it, which causes issues in certain SDL apps since the presence of OpenGL support supersedes the ES/ES2 variants. The workaround is to disable OpenGL at configuration time: ./configure --disable-video-opengl Or if the application uses the Render functions, you can use the SDL_RENDER_DRIVER environment variable: export SDL_RENDER_DRIVER=opengles2 ================================================================================ Notes ================================================================================ When launching apps remotely (via SSH), SDL can prevent local keystrokes from leaking into the console only if it has root privileges. Launching apps locally does not suffer from this issue.","title":"Raspberry Pi"},{"location":"README-raspberrypi/#raspberry-pi","text":"Requirements: Raspbian (other Linux distros may work as well). ================================================================================ Features ================================================================================ Works without X11 Hardware accelerated OpenGL ES 2.x Sound via ALSA Input (mouse/keyboard/joystick) via EVDEV Hotplugging of input devices via UDEV ================================================================================ Raspbian Build Dependencies ================================================================================ sudo apt-get install libudev-dev libasound2-dev libdbus-1-dev You also need the VideoCore binary stuff that ships in /opt/vc for EGL and OpenGL ES 2.x, it usually comes pre-installed, but in any case: sudo apt-get install libraspberrypi0 libraspberrypi-bin libraspberrypi-dev ================================================================================ NEON ================================================================================ If your Pi has NEON support, make sure you add -mfpu=neon to your CFLAGS so that SDL will select some otherwise-disabled highly-optimized code. The original Pi units don't have NEON, the Pi2 probably does, and the Pi3 definitely does. ================================================================================ Cross compiling from x86 Linux ================================================================================ To cross compile SDL for Raspbian from your desktop machine, you'll need a Raspbian system root and the cross compilation tools. We'll assume these tools will be placed in /opt/rpi-tools sudo git clone --depth 1 https://github.com/raspberrypi/tools /opt/rpi-tools You'll also need a Raspbian binary image. Get it from: http://downloads.raspberrypi.org/raspbian_latest After unzipping, you'll get file with a name like: \" -wheezy-raspbian.img\" Let's assume the sysroot will be built in /opt/rpi-sysroot. export SYSROOT=/opt/rpi-sysroot sudo kpartx -a -v <path_to_raspbian_image>.img sudo mount -o loop /dev/mapper/loop0p2 /mnt sudo cp -r /mnt $SYSROOT sudo apt-get install qemu binfmt-support qemu-user-static sudo cp /usr/bin/qemu-arm-static $SYSROOT/usr/bin sudo mount --bind /dev $SYSROOT/dev sudo mount --bind /proc $SYSROOT/proc sudo mount --bind /sys $SYSROOT/sys Now, before chrooting into the ARM sysroot, you'll need to apply a workaround, edit $SYSROOT/etc/ld.so.preload and comment out all lines in it. sudo chroot $SYSROOT apt-get install libudev-dev libasound2-dev libdbus-1-dev libraspberrypi0 libraspberrypi-bin libraspberrypi-dev libx11-dev libxext-dev libxrandr-dev libxcursor-dev libxi-dev libxinerama-dev libxxf86vm-dev libxss-dev exit sudo umount $SYSROOT/dev sudo umount $SYSROOT/proc sudo umount $SYSROOT/sys sudo umount /mnt There's one more fix required, as the libdl.so symlink uses an absolute path which doesn't quite work in our setup. sudo rm -rf $SYSROOT/usr/lib/arm-linux-gnueabihf/libdl.so sudo ln -s ../../../lib/arm-linux-gnueabihf/libdl.so.2 $SYSROOT/usr/lib/arm-linux-gnueabihf/libdl.so The final step is compiling SDL itself. export CC=\"/opt/rpi-tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian/bin/arm-linux-gnueabihf-gcc --sysroot=$SYSROOT -I$SYSROOT/opt/vc/include -I$SYSROOT/usr/include -I$SYSROOT/opt/vc/include/interface/vcos/pthreads -I$SYSROOT/opt/vc/include/interface/vmcs_host/linux\" cd <SDL SOURCE> mkdir -p build;cd build LDFLAGS=\"-L$SYSROOT/opt/vc/lib\" ../configure --with-sysroot=$SYSROOT --host=arm-raspberry-linux-gnueabihf --prefix=$PWD/rpi-sdl2-installed --disable-pulseaudio --disable-esd make make install To be able to deploy this to /usr/local in the Raspbian system you need to fix up a few paths: perl -w -pi -e \"s#$PWD/rpi-sdl2-installed#/usr/local#g;\" ./rpi-sdl2-installed/lib/libSDL2.la ./rpi-sdl2-installed/lib/pkgconfig/sdl2.pc ./rpi-sdl2-installed/bin/sdl2-config ================================================================================ Apps don't work or poor video/audio performance ================================================================================ If you get sound problems, buffer underruns, etc, run \"sudo rpi-update\" to update the RPi's firmware. Note that doing so will fix these problems, but it will also render the CMA - Dynamic Memory Split functionality useless. Also, by default the Raspbian distro configures the GPU RAM at 64MB, this is too low in general, specially if a 1080p TV is hooked up. See here how to configure this setting: http://elinux.org/RPiconfig Using a fixed gpu_mem=128 is the best option (specially if you updated the firmware, using CMA probably won't work, at least it's the current case). ================================================================================ No input ================================================================================ Make sure you belong to the \"input\" group. sudo usermod -aG input `whoami` ================================================================================ No HDMI Audio ================================================================================ If you notice that ALSA works but there's no audio over HDMI, try adding: hdmi_drive=2 to your config.txt file and reboot. Reference: http://www.raspberrypi.org/phpBB3/viewtopic.php?t=5062 ================================================================================ Text Input API support ================================================================================ The Text Input API is supported, with translation of scan codes done via the kernel symbol tables. For this to work, SDL needs access to a valid console. If you notice there's no SDL_TEXTINPUT message being emitted, double check that your app has read access to one of the following: /proc/self/fd/0 /dev/tty /dev/tty[0...6] /dev/vc/0 /dev/console This is usually not a problem if you run from the physical terminal (as opposed to running from a pseudo terminal, such as via SSH). If running from a PTS, a quick workaround is to run your app as root or add yourself to the tty group, then re-login to the system. sudo usermod -aG tty `whoami` The keyboard layout used by SDL is the same as the one the kernel uses. To configure the layout on Raspbian: sudo dpkg-reconfigure keyboard-configuration To configure the locale, which controls which keys are interpreted as letters, this determining the CAPS LOCK behavior: sudo dpkg-reconfigure locales ================================================================================ OpenGL problems ================================================================================ If you have desktop OpenGL headers installed at build time in your RPi or cross compilation environment, support for it will be built in. However, the chipset does not actually have support for it, which causes issues in certain SDL apps since the presence of OpenGL support supersedes the ES/ES2 variants. The workaround is to disable OpenGL at configuration time: ./configure --disable-video-opengl Or if the application uses the Render functions, you can use the SDL_RENDER_DRIVER environment variable: export SDL_RENDER_DRIVER=opengles2 ================================================================================ Notes ================================================================================ When launching apps remotely (via SSH), SDL can prevent local keystrokes from leaking into the console only if it has root privileges. Launching apps locally does not suffer from this issue.","title":"Raspberry Pi"},{"location":"README-touch/","text":"Touch System Specific Notes Linux: The linux touch system is currently based off event streams, and proc/bus/devices. The active user must be given permissions to read /dev/input/TOUCHDEVICE, where TOUCHDEVICE is the event stream for your device. Currently only Wacom tablets are supported. If you have an unsupported tablet contact me at jim.tla+sdl_touch@gmail.com and I will help you get support for it. Mac: The Mac and iPhone APIs are pretty. If your touch device supports them then you'll be fine. If it doesn't, then there isn't much we can do. iPhone: Works out of box. Windows: Unfortunately there is no windows support as of yet. Support for Windows 7 is planned, but we currently have no way to test. If you have a Windows 7 WM_TOUCH supported device, and are willing to help test please contact me at jim.tla+sdl_touch@gmail.com =========================================================================== Events =========================================================================== SDL_FINGERDOWN: Sent when a finger (or stylus) is placed on a touch device. Fields: * event.tfinger.touchId - the Id of the touch device. * event.tfinger.fingerId - the Id of the finger which just went down. * event.tfinger.x - the x coordinate of the touch (0..1) * event.tfinger.y - the y coordinate of the touch (0..1) * event.tfinger.pressure - the pressure of the touch (0..1) SDL_FINGERMOTION: Sent when a finger (or stylus) is moved on the touch device. Fields: Same as SDL_FINGERDOWN but with additional: * event.tfinger.dx - change in x coordinate during this motion event. * event.tfinger.dy - change in y coordinate during this motion event. SDL_FINGERUP: Sent when a finger (or stylus) is lifted from the touch device. Fields: Same as SDL_FINGERDOWN. =========================================================================== Functions =========================================================================== SDL provides the ability to access the underlying SDL_Finger structures. These structures should never be modified. The following functions are included from SDL_touch.h To get a SDL_TouchID call SDL_GetTouchDevice(int index). This returns a SDL_TouchID. IMPORTANT: If the touch has been removed, or there is no touch with the given index, SDL_GetTouchDevice() will return 0. Be sure to check for this! The number of touch devices can be queried with SDL_GetNumTouchDevices(). A SDL_TouchID may be used to get pointers to SDL_Finger. SDL_GetNumTouchFingers(touchID) may be used to get the number of fingers currently down on the device. The most common reason to access SDL_Finger is to query the fingers outside the event. In most cases accessing the fingers is using the event. This would be accomplished by code like the following: float x = event.tfinger.x; float y = event.tfinger.y; To get a SDL_Finger, call SDL_GetTouchFinger(SDL_TouchID touchID, int index), where touchID is a SDL_TouchID, and index is the requested finger. This returns a SDL_Finger *, or NULL if the finger does not exist, or has been removed. A SDL_Finger is guaranteed to be persistent for the duration of a touch, but it will be de-allocated as soon as the finger is removed. This occurs when the SDL_FINGERUP event is added to the event queue, and thus before the SDL_FINGERUP event is polled. As a result, be very careful to check for NULL return values. A SDL_Finger has the following fields: * x, y: The current coordinates of the touch. * pressure: The pressure of the touch. =========================================================================== Notes =========================================================================== For a complete example see test/testgesture.c Please direct questions/comments to: jim.tla+sdl_touch@gmail.com (original author, API was changed since)","title":"Touch"},{"location":"README-touch/#touch","text":"","title":"Touch"},{"location":"README-touch/#system-specific-notes","text":"Linux: The linux touch system is currently based off event streams, and proc/bus/devices. The active user must be given permissions to read /dev/input/TOUCHDEVICE, where TOUCHDEVICE is the event stream for your device. Currently only Wacom tablets are supported. If you have an unsupported tablet contact me at jim.tla+sdl_touch@gmail.com and I will help you get support for it. Mac: The Mac and iPhone APIs are pretty. If your touch device supports them then you'll be fine. If it doesn't, then there isn't much we can do. iPhone: Works out of box. Windows: Unfortunately there is no windows support as of yet. Support for Windows 7 is planned, but we currently have no way to test. If you have a Windows 7 WM_TOUCH supported device, and are willing to help test please contact me at jim.tla+sdl_touch@gmail.com =========================================================================== Events =========================================================================== SDL_FINGERDOWN: Sent when a finger (or stylus) is placed on a touch device. Fields: * event.tfinger.touchId - the Id of the touch device. * event.tfinger.fingerId - the Id of the finger which just went down. * event.tfinger.x - the x coordinate of the touch (0..1) * event.tfinger.y - the y coordinate of the touch (0..1) * event.tfinger.pressure - the pressure of the touch (0..1) SDL_FINGERMOTION: Sent when a finger (or stylus) is moved on the touch device. Fields: Same as SDL_FINGERDOWN but with additional: * event.tfinger.dx - change in x coordinate during this motion event. * event.tfinger.dy - change in y coordinate during this motion event. SDL_FINGERUP: Sent when a finger (or stylus) is lifted from the touch device. Fields: Same as SDL_FINGERDOWN. =========================================================================== Functions =========================================================================== SDL provides the ability to access the underlying SDL_Finger structures. These structures should never be modified. The following functions are included from SDL_touch.h To get a SDL_TouchID call SDL_GetTouchDevice(int index). This returns a SDL_TouchID. IMPORTANT: If the touch has been removed, or there is no touch with the given index, SDL_GetTouchDevice() will return 0. Be sure to check for this! The number of touch devices can be queried with SDL_GetNumTouchDevices(). A SDL_TouchID may be used to get pointers to SDL_Finger. SDL_GetNumTouchFingers(touchID) may be used to get the number of fingers currently down on the device. The most common reason to access SDL_Finger is to query the fingers outside the event. In most cases accessing the fingers is using the event. This would be accomplished by code like the following: float x = event.tfinger.x; float y = event.tfinger.y; To get a SDL_Finger, call SDL_GetTouchFinger(SDL_TouchID touchID, int index), where touchID is a SDL_TouchID, and index is the requested finger. This returns a SDL_Finger *, or NULL if the finger does not exist, or has been removed. A SDL_Finger is guaranteed to be persistent for the duration of a touch, but it will be de-allocated as soon as the finger is removed. This occurs when the SDL_FINGERUP event is added to the event queue, and thus before the SDL_FINGERUP event is polled. As a result, be very careful to check for NULL return values. A SDL_Finger has the following fields: * x, y: The current coordinates of the touch. * pressure: The pressure of the touch. =========================================================================== Notes =========================================================================== For a complete example see test/testgesture.c Please direct questions/comments to: jim.tla+sdl_touch@gmail.com (original author, API was changed since)","title":"System Specific Notes"},{"location":"README-visualc/","text":"Using SDL with Microsoft Visual C++ by Lion Kimbro with additions by James Turk You can either use the precompiled libraries from the SDL web site, or you can build SDL yourself. Building SDL To build SDL, your machine must, at a minimum, have the DirectX9.0c SDK installed. It may or may not be retrievable from the Microsoft website, so you might need to locate it online . Editor's note: I've been able to successfully build SDL using Visual Studio 2019 without the DX9.0c SDK Open the Visual Studio solution file at ./VisualC/SDL.sln . Your IDE will likely prompt you to upgrade this solution file to whatever later version of the IDE you're using. In the Retarget Projects dialog, all of the affected project files should be checked allowing you to use the latest Windows SDK Version you have installed, along with the Platform Toolset . If you choose NOT to upgrade to use the latest Windows SDK Version or Platform Toolset , then you'll need the Visual Studio 2010 Platform Toolset . Build the .dll and .lib files by right clicking on each project in turn (Projects are listed in the Workspace panel in the FileView tab), and selecting Build . You may get a few warnings, but you should not get any errors. Later, we will refer to the following .lib and .dll files that have just been generated: ./VisualC/Win32/Debug/SDL2.dll or ./VisualC/Win32/Release/SDL2.dll ./VisualC/Win32/Debug/SDL2.lib or ./VisualC/Win32/Release/SDL2.lib ./VisualC/Win32/Debug/SDL2main.lib or ./VisualC/Win32/Release/SDL2main.lib Note for the x64 versions, just replace Win32 in the path with x64 Creating a Project with SDL Create a project as a Win32 Application . Create a C++ file for your project. Set the C runtime to Multi-threaded DLL in the menu: Project|Settings|C/C++ tab|Code Generation|Runtime Library . Add the SDL include directory to your list of includes in the menu: Project|Settings|C/C++ tab|Preprocessor|Additional include directories VC7 Specific: Instead of doing this, I find it easier to add the include and library directories to the list that VC7 keeps. Do this by selecting Tools|Options|Projects|VC++ Directories and under the \"Show Directories For:\" dropbox select \"Include Files\", and click the \"New Directory Icon\" and add the [SDLROOT]\\include directory (e.g. If you installed to c:\\SDL\\ add c:\\SDL\\include). Proceed to change the dropbox selection to \"Library Files\" and add [SDLROOT]\\lib. The \"include directory\" I am referring to is the ./include folder. Now we're going to use the files that we had created earlier in the Build SDL step. Copy the following file into your Project directory: SDL2.dll Add the following files to your project (It is not necessary to copy them to your project directory): SDL2.lib SDL2main.lib To add them to your project, right click on your project, and select Add files to project . Instead of adding the files to your project, it is more desirable to add them to the linker options: Project|Properties|Linker|Command Line and type the names of the libraries to link with in the \"Additional Options:\" box. Note: This must be done for each build configuration (e.g. Release,Debug). Hello SDL2 Here's a sample SDL snippet to verify everything is setup in your IDE: ``` #include \"SDL.h\" int main( int argc, char* argv[] ) { const int WIDTH = 640; const int HEIGHT = 480; SDL_Window* window = NULL; SDL_Renderer* renderer = NULL; SDL_Init(SDL_INIT_VIDEO); window = SDL_CreateWindow(\"SDL2 Test\", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, WIDTH, HEIGHT, SDL_WINDOW_SHOWN); renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC); SDL_DestroyRenderer(renderer); SDL_DestroyWindow(window); SDL_Quit(); return 0; } ``` That's it! I hope that this document has helped you get through the most difficult part of using the SDL: installing it. Suggestions for improvements should be posted to the Github Issues . Credits Thanks to Paulus Esterhazy , for the work on VC++ port. This document was originally called \"VisualC.txt\", and was written by Sam Lantinga . Later, it was converted to HTML and expanded into the document that you see today by Lion Kimbro . Minor Fixes and Visual C++ 7 Information (In Green) was added by James Turk","title":"VisualC"},{"location":"README-visualc/#using-sdl-with-microsoft-visual-c","text":"","title":"Using SDL with Microsoft Visual C++"},{"location":"README-wince/","text":"WinCE Windows CE is no longer supported by SDL. We have left the CE support in SDL 1.2 for those that must have it, and we have support for Windows Phone 8 and WinRT in SDL2, as of SDL 2.0.3. --ryan.","title":"WinCE"},{"location":"README-wince/#wince","text":"Windows CE is no longer supported by SDL. We have left the CE support in SDL 1.2 for those that must have it, and we have support for Windows Phone 8 and WinRT in SDL2, as of SDL 2.0.3. --ryan.","title":"WinCE"},{"location":"README-windows/","text":"Windows ================================================================================ OpenGL ES 2.x support ================================================================================ SDL has support for OpenGL ES 2.x under Windows via two alternative implementations. The most straightforward method consists in running your app in a system with a graphic card paired with a relatively recent (as of November of 2013) driver which supports the WGL_EXT_create_context_es2_profile extension. Vendors known to ship said extension on Windows currently include nVidia and Intel. The other method involves using the ANGLE library (https://code.google.com/p/angleproject/) If an OpenGL ES 2.x context is requested and no WGL_EXT_create_context_es2_profile extension is found, SDL will try to load the libEGL.dll library provided by ANGLE. To obtain the ANGLE binaries, you can either compile from source from https://chromium.googlesource.com/angle/angle or copy the relevant binaries from a recent Chrome/Chromium install for Windows. The files you need are: * libEGL.dll * libGLESv2.dll * d3dcompiler_46.dll (supports Windows Vista or later, better shader compiler) or... * d3dcompiler_43.dll (supports Windows XP or later) If you compile ANGLE from source, you can configure it so it does not need the d3dcompiler_* DLL at all (for details on this, see their documentation). However, by default SDL will try to preload the d3dcompiler_46.dll to comply with ANGLE's requirements. If you wish SDL to preload d3dcompiler_43.dll (to support Windows XP) or to skip this step at all, you can use the SDL_HINT_VIDEO_WIN_D3DCOMPILER hint (see SDL_hints.h for more details). Known Bugs: * SDL_GL_SetSwapInterval is currently a no op when using ANGLE. It appears that there's a bug in the library which prevents the window contents from refreshing if this is set to anything other than the default value. Vulkan Surface Support Support for creating Vulkan surfaces is configured on by default. To disable it change the value of SDL_VIDEO_VULKAN to 0 in SDL_config_windows.h . You must install the Vulkan SDK in order to use Vulkan graphics in your application.","title":"Windows"},{"location":"README-windows/#windows","text":"================================================================================ OpenGL ES 2.x support ================================================================================ SDL has support for OpenGL ES 2.x under Windows via two alternative implementations. The most straightforward method consists in running your app in a system with a graphic card paired with a relatively recent (as of November of 2013) driver which supports the WGL_EXT_create_context_es2_profile extension. Vendors known to ship said extension on Windows currently include nVidia and Intel. The other method involves using the ANGLE library (https://code.google.com/p/angleproject/) If an OpenGL ES 2.x context is requested and no WGL_EXT_create_context_es2_profile extension is found, SDL will try to load the libEGL.dll library provided by ANGLE. To obtain the ANGLE binaries, you can either compile from source from https://chromium.googlesource.com/angle/angle or copy the relevant binaries from a recent Chrome/Chromium install for Windows. The files you need are: * libEGL.dll * libGLESv2.dll * d3dcompiler_46.dll (supports Windows Vista or later, better shader compiler) or... * d3dcompiler_43.dll (supports Windows XP or later) If you compile ANGLE from source, you can configure it so it does not need the d3dcompiler_* DLL at all (for details on this, see their documentation). However, by default SDL will try to preload the d3dcompiler_46.dll to comply with ANGLE's requirements. If you wish SDL to preload d3dcompiler_43.dll (to support Windows XP) or to skip this step at all, you can use the SDL_HINT_VIDEO_WIN_D3DCOMPILER hint (see SDL_hints.h for more details). Known Bugs: * SDL_GL_SetSwapInterval is currently a no op when using ANGLE. It appears that there's a bug in the library which prevents the window contents from refreshing if this is set to anything other than the default value.","title":"Windows"},{"location":"README-windows/#vulkan-surface-support","text":"Support for creating Vulkan surfaces is configured on by default. To disable it change the value of SDL_VIDEO_VULKAN to 0 in SDL_config_windows.h . You must install the Vulkan SDK in order to use Vulkan graphics in your application.","title":"Vulkan Surface Support"},{"location":"README-winrt/","text":"WinRT This port allows SDL applications to run on Microsoft's platforms that require use of \"Windows Runtime\", aka. \"WinRT\", APIs. Microsoft may, in some cases, refer to them as either \"Windows Store\", or for Windows 10, \"UWP\" apps. Some of the operating systems that include WinRT, are: Windows 10, via its Universal Windows Platform (UWP) APIs Windows 8.x Windows RT 8.x (aka. Windows 8.x for ARM processors) Windows Phone 8.x Requirements Microsoft Visual C++ (aka Visual Studio), either 2017, 2015, 2013, or 2012 Free, \"Community\" or \"Express\" editions may be used, so long as they include support for either \"Windows Store\" or \"Windows Phone\" apps. \"Express\" versions marked as supporting \"Windows Desktop\" development typically do not include support for creating WinRT apps, to note. (The \"Community\" editions of Visual C++ do, however, support both desktop/Win32 and WinRT development). Visual Studio 2017 can be used, however it is recommended that you install the Visual C++ 2015 build tools. These build tools can be installed using VS 2017's installer. Be sure to also install the workload for \"Universal Windows Platform development\", its optional component, the \"C++ Universal Windows Platform tools\", and for UWP / Windows 10 development, the \"Windows 10 SDK (10.0.10240.0)\". Please note that targeting UWP / Windows 10 apps from development machine(s) running earlier versions of Windows, such as Windows 7, is not always supported by Visual Studio, and you may get error(s) when attempting to do so. Visual C++ 2012 can only build apps that target versions 8.0 of Windows, or Windows Phone. 8.0-targeted apps will run on devices running 8.1 editions of Windows, however they will not be able to take advantage of 8.1-specific features. Visual C++ 2013 cannot create app projects that target Windows 8.0. Visual C++ 2013 Update 4, can create app projects for Windows Phone 8.0, Windows Phone 8.1, and Windows 8.1, but not Windows 8.0. An optional Visual Studio add-in, \"Tools for Maintaining Store apps for Windows 8\", allows Visual C++ 2013 to load and build Windows 8.0 projects that were created with Visual C++ 2012, so long as Visual C++ 2012 is installed on the same machine. More details on targeting different versions of Windows can found at the following web pages: Develop apps by using Visual Studio 2013 To add the Tools for Maintaining Store apps for Windows 8 A valid Microsoft account - This requirement is not imposed by SDL, but rather by Microsoft's Visual C++ toolchain. This is required to launch or debug apps. Status Here is a rough list of what works, and what doesn't: What works: compilation via Visual C++ 2012 through 2015 compile-time platform detection for SDL programs. The C/C++ #define, __WINRT__ , will be set to 1 (by SDL) when compiling for WinRT. GPU-accelerated 2D rendering, via SDL_Renderer. OpenGL ES 2, via the ANGLE library (included separately from SDL) software rendering, via either SDL_Surface (optionally in conjunction with SDL_GetWindowSurface() and SDL_UpdateWindowSurface()) or via the SDL_Renderer APIs threads timers (via SDL_GetTicks(), SDL_AddTimer(), SDL_GetPerformanceCounter(), SDL_GetPerformanceFrequency(), etc.) file I/O via SDL_RWops mouse input (unsupported on Windows Phone) audio, via SDL's WASAPI backend (if you want to record, your app must have \"Microphone\" capabilities enabled in its manifest, and the user must not have blocked access. Otherwise, capture devices will fail to work, presenting as a device disconnect shortly after opening it.) .DLL file loading. Libraries MUST be packaged inside applications. Loading anything outside of the app is not supported. system path retrieval via SDL's filesystem APIs game controllers. Support is provided via the SDL_Joystick and SDL_GameController APIs, and is backed by Microsoft's XInput API. Please note, however, that Windows limits game-controller support in UWP apps to, \"Xbox compatible controllers\" (many controllers that work in Win32 apps, do not work in UWP, due to restrictions in UWP itself.) multi-touch input app events. SDL_APP_WILLENTER and SDL_APP_DIDENTER events get sent out as appropriate. window events using Direct3D 11.x APIs outside of SDL. Non-XAML / Direct3D-only apps can choose to render content directly via Direct3D, using SDL to manage the internal WinRT window, as well as input and audio. (Use SDL_GetWindowWMInfo() to get the WinRT 'CoreWindow', and pass it into IDXGIFactory2::CreateSwapChainForCoreWindow() as appropriate.) What partially works: keyboard input. Most of WinRT's documented virtual keys are supported, as well as many keys with documented hardware scancodes. Converting SDL_Scancodes to or from SDL_Keycodes may not work, due to missing APIs (MapVirtualKey()) in Microsoft's Windows Store / UWP APIs. SDLmain. WinRT uses a different signature for each app's main() function. SDL-based apps that use this port must compile in SDL_winrt_main_NonXAML.cpp (in SDL\\src\\main\\winrt\\ ) directly in order for their C-style main() functions to be called. What doesn't work: compilation with anything other than Visual C++ programmatically-created custom cursors. These don't appear to be supported by WinRT. Different OS-provided cursors can, however, be created via SDL_CreateSystemCursor() (unsupported on Windows Phone) SDL_WarpMouseInWindow() or SDL_WarpMouseGlobal(). This are not currently supported by WinRT itself. joysticks and game controllers that either are not supported by Microsoft's XInput API, or are not supported within UWP apps (many controllers that work in Win32, do not work in UWP, due to restrictions in UWP itself). turning off VSync when rendering on Windows Phone. Attempts to turn VSync off on Windows Phone result either in Direct3D not drawing anything, or it forcing VSync back on. As such, SDL_RENDERER_PRESENTVSYNC will always get turned-on on Windows Phone. This limitation is not present in non-Phone WinRT (such as Windows 8.x), where turning off VSync appears to work. probably anything else that's not listed as supported Upgrade Notes SDL_GetPrefPath() usage when upgrading WinRT apps from SDL 2.0.3 SDL 2.0.4 fixes two bugs found in the WinRT version of SDL_GetPrefPath(). The fixes may affect older, SDL 2.0.3-based apps' save data. Please note that these changes only apply to SDL-based WinRT apps, and not to apps for any other platform. SDL_GetPrefPath() would return an invalid path, one in which the path's directory had not been created. Attempts to create files there (via fopen(), for example), would fail, unless that directory was explicitly created beforehand. SDL_GetPrefPath(), for non-WinPhone-based apps, would return a path inside a WinRT 'Roaming' folder, the contents of which get automatically synchronized across multiple devices. This process can occur while an application runs, and can cause existing save-data to be overwritten at unexpected times, with data from other devices. (Windows Phone apps written with SDL 2.0.3 did not utilize a Roaming folder, due to API restrictions in Windows Phone 8.0). SDL_GetPrefPath(), starting with SDL 2.0.4, addresses these by: making sure that SDL_GetPrefPath() returns a directory in which data can be written to immediately, without first needing to create directories. basing SDL_GetPrefPath() off of a different, non-Roaming folder, the contents of which do not automatically get synchronized across devices (and which require less work to use safely, in terms of data integrity). Apps that wish to get their Roaming folder's path can do so either by using SDL_WinRTGetFSPathUTF8(), SDL_WinRTGetFSPathUNICODE() (which returns a UCS-2/wide-char string), or directly through the WinRT class, Windows.Storage.ApplicationData. Setup, High-Level Steps The steps for setting up a project for an SDL/WinRT app looks like the following, at a high-level: create a new Visual C++ project using Microsoft's template for a, \"Direct3D App\". remove most of the files from the project. make your app's project directly reference SDL/WinRT's own Visual C++ project file, via use of Visual C++'s \"References\" dialog. This will setup the linker, and will copy SDL's .dll files to your app's final output. adjust your app's build settings, at minimum, telling it where to find SDL's header files. add files that contains a WinRT-appropriate main function, along with some data to make sure mouse-cursor-hiding (via SDL_ShowCursor(SDL_DISABLE) calls) work properly. add SDL-specific app code. build and run your app. Setup, Detailed Steps 1. Create a new project Create a new project using one of Visual C++'s templates for a plain, non-XAML, \"Direct3D App\" (XAML support for SDL/WinRT is not yet ready for use). If you don't see one of these templates, in Visual C++'s 'New Project' dialog, try using the textbox titled, 'Search Installed Templates' to look for one. 2. Remove unneeded files from the project In the new project, delete any file that has one of the following extensions: .cpp .h .hlsl When you are done, you should be left with a few files, each of which will be a necessary part of your app's project. These files will consist of: an .appxmanifest file, which contains metadata on your WinRT app. This is similar to an Info.plist file on iOS, or an AndroidManifest.xml on Android. a few .png files, one of which is a splash screen (displayed when your app launches), others are app icons. a .pfx file, used for code signing purposes. 3. Add references to SDL's project files SDL/WinRT can be built in multiple variations, spanning across three different CPU architectures (x86, x64, and ARM) and two different configurations (Debug and Release). WinRT and Visual C++ do not currently provide a means for combining multiple variations of one library into a single file. Furthermore, it does not provide an easy means for copying pre-built .dll files into your app's final output (via Post-Build steps, for example). It does, however, provide a system whereby an app can reference the MSVC projects of libraries such that, when the app is built: each library gets built for the appropriate CPU architecture(s) and WinRT platform(s). each library's output, such as .dll files, get copied to the app's build output. To set this up for SDL/WinRT, you'll need to run through the following steps: open up the Solution Explorer inside Visual C++ (under the \"View\" menu, then \"Solution Explorer\") right click on your app's solution. navigate to \"Add\", then to \"Existing Project...\" find SDL/WinRT's Visual C++ project file and open it. Different project files exist for different WinRT platforms. All of them are in SDL's source distribution, in the following directories: VisualC-WinRT/UWP_VS2015/ - for Windows 10 / UWP apps VisualC-WinRT/WinPhone81_VS2013/ - for Windows Phone 8.1 apps VisualC-WinRT/WinRT80_VS2012/ - for Windows 8.0 apps VisualC-WinRT/WinRT81_VS2013/ - for Windows 8.1 apps once the project has been added, right-click on your app's project and select, \"References...\" click on the button titled, \"Add New Reference...\" check the box next to SDL click OK to close the dialog SDL will now show up in the list of references. Click OK to close that dialog. Your project is now linked to SDL's project, insofar that when the app is built, SDL will be built as well, with its build output getting included with your app. 4. Adjust Your App's Build Settings Some build settings need to be changed in your app's project. This guide will outline the following: making sure that the compiler knows where to find SDL's header files Optional for C++, but NECESSARY for compiling C code: telling the compiler not to use Microsoft's C++ extensions for WinRT development. Optional: telling the compiler not generate errors due to missing precompiled header files. To change these settings: right-click on the project choose \"Properties\" in the drop-down box next to \"Configuration\", choose, \"All Configurations\" in the drop-down box next to \"Platform\", choose, \"All Platforms\" in the left-hand list, expand the \"C/C++\" section select \"General\" edit the \"Additional Include Directories\" setting, and add a path to SDL's \"include\" directory Optional: to enable compilation of C code: change the setting for \"Consume Windows Runtime Extension\" from \"Yes (/ZW)\" to \"No\". If you're working with a completely C++ based project, this step can usually be omitted. Optional: to disable precompiled headers (which can produce 'stdafx.h'-related build errors, if setup incorrectly: in the left-hand list, select \"Precompiled Headers\", then change the setting for \"Precompiled Header\" from \"Use (/Yu)\" to \"Not Using Precompiled Headers\". close the dialog, saving settings, by clicking the \"OK\" button 5. Add a WinRT-appropriate main function, and a blank-cursor image, to the app. A few files should be included directly in your app's MSVC project, specifically: 1. a WinRT-appropriate main function (which is different than main() functions on other platforms) 2. a Win32-style cursor resource, used by SDL_ShowCursor() to hide the mouse cursor (if and when the app needs to do so). If this cursor resource is not included, mouse-position reporting may fail if and when the cursor is hidden, due to possible bugs/design-oddities in Windows itself. To include these files for C/C++ projects: right-click on your project (again, in Visual C++'s Solution Explorer), navigate to \"Add\", then choose \"Existing Item...\". navigate to the directory containing SDL's source code, then into its subdirectory, 'src/main/winrt/'. Select, then add, the following files: SDL_winrt_main_NonXAML.cpp SDL2-WinRTResources.rc SDL2-WinRTResource_BlankCursor.cur right-click on the file SDL_winrt_main_NonXAML.cpp (as listed in your project), then click on \"Properties...\". in the drop-down box next to \"Configuration\", choose, \"All Configurations\" in the drop-down box next to \"Platform\", choose, \"All Platforms\" in the left-hand list, click on \"C/C++\" change the setting for \"Consume Windows Runtime Extension\" to \"Yes (/ZW)\". click the OK button. This will close the dialog. NOTE: C++/CX compilation is currently required in at least one file of your app's project. This is to make sure that Visual C++'s linker builds a 'Windows Metadata' file (.winmd) for your app. Not doing so can lead to build errors. For non-C++ projects, you will need to call SDL_WinRTRunApp from your language's main function, and generate SDL2-WinRTResources.res manually by using rc via the Developer Command Prompt and including it as a within the first block in your Visual Studio project file. 6. Add app code and assets At this point, you can add in SDL-specific source code. Be sure to include a C-style main function (ie: int main(int argc, char *argv[]) ). From there you should be able to create a single SDL_Window (WinRT apps can only have one window, at present), as well as an SDL_Renderer . Direct3D will be used to draw content. Events are received via SDL's usual event functions ( SDL_PollEvent , etc.) If you have a set of existing source files and assets, you can start adding them to the project now. If not, or if you would like to make sure that you're setup correctly, some short and simple sample code is provided below. 6.A. ... when creating a new app If you are creating a new app (rather than porting an existing SDL-based app), or if you would just like a simple app to test SDL/WinRT with before trying to get existing code working, some working SDL/WinRT code is provided below. To set this up: right click on your app's project select Add, then New Item. An \"Add New Item\" dialog will show up. from the left-hand list, choose \"Visual C++\" from the middle/main list, choose \"C++ File (.cpp)\" near the bottom of the dialog, next to \"Name:\", type in a name for your source file, such as, \"main.cpp\". click on the Add button. This will close the dialog, add the new file to your project, and open the file in Visual C++'s text editor. Copy and paste the following code into the new file, then save it. include int main(int argc, char **argv) { SDL_DisplayMode mode; SDL_Window * window = NULL; SDL_Renderer * renderer = NULL; SDL_Event evt; if (SDL_Init(SDL_INIT_VIDEO) != 0) { return 1; } if (SDL_GetCurrentDisplayMode(0, &mode) != 0) { return 1; } if (SDL_CreateWindowAndRenderer(mode.w, mode.h, SDL_WINDOW_FULLSCREEN, &window, &renderer) != 0) { return 1; } while (1) { while (SDL_PollEvent(&evt)) { } SDL_SetRenderDrawColor(renderer, 0, 255, 0, 255); SDL_RenderClear(renderer); SDL_RenderPresent(renderer); } } 6.B. Adding code and assets If you have existing code and assets that you'd like to add, you should be able to add them now. The process for adding a set of files is as such. right click on the app's project select Add, then click on \"New Item...\" open any source, header, or asset files as appropriate. Support for C and C++ is available. Do note that WinRT only supports a subset of the APIs that are available to Win32-based apps. Many portions of the Win32 API and the C runtime are not available. A list of unsupported C APIs can be found at http://msdn.microsoft.com/en-us/library/windows/apps/jj606124.aspx General information on using the C runtime in WinRT can be found at https://msdn.microsoft.com/en-us/library/hh972425.aspx A list of supported Win32 APIs for WinRT apps can be found at http://msdn.microsoft.com/en-us/library/windows/apps/br205757.aspx . To note, the list of supported Win32 APIs for Windows Phone 8.0 is different. That list can be found at http://msdn.microsoft.com/en-us/library/windowsphone/develop/jj662956(v=vs.105).aspx 7. Build and run your app Your app project should now be setup, and you should be ready to build your app. To run it on the local machine, open the Debug menu and choose \"Start Debugging\". This will build your app, then run your app full-screen. To switch out of your app, press the Windows key. Alternatively, you can choose to run your app in a window. To do this, before building and running your app, find the drop-down menu in Visual C++'s toolbar that says, \"Local Machine\". Expand this by clicking on the arrow on the right side of the list, then click on Simulator. Once you do that, any time you build and run the app, the app will launch in window, rather than full-screen. 7.A. Running apps on older, ARM-based, \"Windows RT\" devices These instructions do not include Windows Phone, despite Windows Phone typically running on ARM processors. They are specifically for devices that use the \"Windows RT\" operating system, which was a modified version of Windows 8.x that ran primarily on ARM-based tablet computers. To build and run the app on ARM-based, \"Windows RT\" devices, you'll need to: install Microsoft's \"Remote Debugger\" on the device. Visual C++ installs and debugs ARM-based apps via IP networks. change a few options on the development machine, both to make sure it builds for ARM (rather than x86 or x64), and to make sure it knows how to find the Windows RT device (on the network). Microsoft's Remote Debugger can be found at https://msdn.microsoft.com/en-us/library/hh441469.aspx . Please note that separate versions of this debugger exist for different versions of Visual C++, one each for MSVC 2015, 2013, and 2012. To setup Visual C++ to launch your app on an ARM device: make sure the Remote Debugger is running on your ARM device, and that it's on the same IP network as your development machine. from Visual C++'s toolbar, find a drop-down menu that says, \"Win32\". Click it, then change the value to \"ARM\". make sure Visual C++ knows the hostname or IP address of the ARM device. To do this: open the app project's properties select \"Debugging\" next to \"Machine Name\", enter the hostname or IP address of the ARM device if, and only if, you've turned off authentication in the Remote Debugger, then change the setting for \"Require Authentication\" to No click \"OK\" build and run the app (from Visual C++). The first time you do this, a prompt will show up on the ARM device, asking for a Microsoft Account. You do, unfortunately, need to log in here, and will need to follow the subsequent registration steps in order to launch the app. After you do so, if the app didn't already launch, try relaunching it again from within Visual C++. Troubleshooting Build fails with message, \"error LNK2038: mismatch detected for 'vccorlib_lib_should_be_specified_before_msvcrt_lib_to_linker'\" Try adding the following to your linker flags. In MSVC, this can be done by right-clicking on the app project, navigating to Configuration Properties -> Linker -> Command Line, then adding them to the Additional Options section. For Release builds / MSVC-Configurations, add: /nodefaultlib:vccorlib /nodefaultlib:msvcrt vccorlib.lib msvcrt.lib For Debug builds / MSVC-Configurations, add: /nodefaultlib:vccorlibd /nodefaultlib:msvcrtd vccorlibd.lib msvcrtd.lib Mouse-motion events fail to get sent, or SDL_GetMouseState() fails to return updated values This may be caused by a bug in Windows itself, whereby hiding the mouse cursor can cause mouse-position reporting to fail. SDL provides a workaround for this, but it requires that an app links to a set of Win32-style cursor image-resource files. A copy of suitable resource files can be found in src/main/winrt/ . Adding them to an app's Visual C++ project file should be sufficient to get the app to use them. SDL's Visual Studio project file fails to open, with message, \"The system can't find the file specified.\" This can be caused for any one of a few reasons, which Visual Studio can report, but won't always do so in an up-front manner. To help determine why this error comes up: open a copy of Visual Studio without opening a project file. This can be accomplished via Windows' Start Menu, among other means. show Visual Studio's Output window. This can be done by going to VS' menu bar, then to View, and then to Output. try opening the SDL project file directly by going to VS' menu bar, then to File, then to Open, then to Project/Solution. When a File-Open dialog appears, open the SDL project (such as the one in SDL's source code, in its directory, VisualC-WinRT/UWP_VS2015/). after attempting to open SDL's Visual Studio project file, additional error information will be output to the Output window. If Visual Studio reports (via its Output window) that the project: \"could not be loaded because it's missing install components. To fix this launch Visual Studio setup with the following selections: Microsoft.VisualStudio.ComponentGroup.UWP.VC\" ... then you will need to re-launch Visual Studio's installer, and make sure that the workflow for \"Universal Windows Platform development\" is checked, and that its optional component, \"C++ Universal Windows Platform tools\" is also checked. While you are there, if you are planning on targeting UWP / Windows 10, also make sure that you check the optional component, \"Windows 10 SDK (10.0.10240.0)\". After making sure these items are checked as-appropriate, install them. Once you install these components, try re-launching Visual Studio, and re-opening the SDL project file. If you still get the error dialog, try using the Output window, again, seeing what Visual Studio says about it. Game controllers / joysticks aren't working! Windows only permits certain game controllers and joysticks to work within WinRT / UWP apps. Even if a game controller or joystick works in a Win32 app, that device is not guaranteed to work inside a WinRT / UWP app. According to Microsoft, \"Xbox compatible controllers\" should work inside UWP apps, potentially with more working in the future. This includes, but may not be limited to, Microsoft-made Xbox controllers and USB adapters. (Source: https://social.msdn.microsoft.com/Forums/en-US/9064838b-e8c3-4c18-8a83-19bf0dfe150d/xinput-fails-to-detect-game-controllers?forum=wpdevelop)","title":"WinRT"},{"location":"README-winrt/#winrt","text":"This port allows SDL applications to run on Microsoft's platforms that require use of \"Windows Runtime\", aka. \"WinRT\", APIs. Microsoft may, in some cases, refer to them as either \"Windows Store\", or for Windows 10, \"UWP\" apps. Some of the operating systems that include WinRT, are: Windows 10, via its Universal Windows Platform (UWP) APIs Windows 8.x Windows RT 8.x (aka. Windows 8.x for ARM processors) Windows Phone 8.x","title":"WinRT"},{"location":"README-winrt/#requirements","text":"Microsoft Visual C++ (aka Visual Studio), either 2017, 2015, 2013, or 2012 Free, \"Community\" or \"Express\" editions may be used, so long as they include support for either \"Windows Store\" or \"Windows Phone\" apps. \"Express\" versions marked as supporting \"Windows Desktop\" development typically do not include support for creating WinRT apps, to note. (The \"Community\" editions of Visual C++ do, however, support both desktop/Win32 and WinRT development). Visual Studio 2017 can be used, however it is recommended that you install the Visual C++ 2015 build tools. These build tools can be installed using VS 2017's installer. Be sure to also install the workload for \"Universal Windows Platform development\", its optional component, the \"C++ Universal Windows Platform tools\", and for UWP / Windows 10 development, the \"Windows 10 SDK (10.0.10240.0)\". Please note that targeting UWP / Windows 10 apps from development machine(s) running earlier versions of Windows, such as Windows 7, is not always supported by Visual Studio, and you may get error(s) when attempting to do so. Visual C++ 2012 can only build apps that target versions 8.0 of Windows, or Windows Phone. 8.0-targeted apps will run on devices running 8.1 editions of Windows, however they will not be able to take advantage of 8.1-specific features. Visual C++ 2013 cannot create app projects that target Windows 8.0. Visual C++ 2013 Update 4, can create app projects for Windows Phone 8.0, Windows Phone 8.1, and Windows 8.1, but not Windows 8.0. An optional Visual Studio add-in, \"Tools for Maintaining Store apps for Windows 8\", allows Visual C++ 2013 to load and build Windows 8.0 projects that were created with Visual C++ 2012, so long as Visual C++ 2012 is installed on the same machine. More details on targeting different versions of Windows can found at the following web pages: Develop apps by using Visual Studio 2013 To add the Tools for Maintaining Store apps for Windows 8 A valid Microsoft account - This requirement is not imposed by SDL, but rather by Microsoft's Visual C++ toolchain. This is required to launch or debug apps.","title":"Requirements"},{"location":"README-winrt/#status","text":"Here is a rough list of what works, and what doesn't: What works: compilation via Visual C++ 2012 through 2015 compile-time platform detection for SDL programs. The C/C++ #define, __WINRT__ , will be set to 1 (by SDL) when compiling for WinRT. GPU-accelerated 2D rendering, via SDL_Renderer. OpenGL ES 2, via the ANGLE library (included separately from SDL) software rendering, via either SDL_Surface (optionally in conjunction with SDL_GetWindowSurface() and SDL_UpdateWindowSurface()) or via the SDL_Renderer APIs threads timers (via SDL_GetTicks(), SDL_AddTimer(), SDL_GetPerformanceCounter(), SDL_GetPerformanceFrequency(), etc.) file I/O via SDL_RWops mouse input (unsupported on Windows Phone) audio, via SDL's WASAPI backend (if you want to record, your app must have \"Microphone\" capabilities enabled in its manifest, and the user must not have blocked access. Otherwise, capture devices will fail to work, presenting as a device disconnect shortly after opening it.) .DLL file loading. Libraries MUST be packaged inside applications. Loading anything outside of the app is not supported. system path retrieval via SDL's filesystem APIs game controllers. Support is provided via the SDL_Joystick and SDL_GameController APIs, and is backed by Microsoft's XInput API. Please note, however, that Windows limits game-controller support in UWP apps to, \"Xbox compatible controllers\" (many controllers that work in Win32 apps, do not work in UWP, due to restrictions in UWP itself.) multi-touch input app events. SDL_APP_WILLENTER and SDL_APP_DIDENTER events get sent out as appropriate. window events using Direct3D 11.x APIs outside of SDL. Non-XAML / Direct3D-only apps can choose to render content directly via Direct3D, using SDL to manage the internal WinRT window, as well as input and audio. (Use SDL_GetWindowWMInfo() to get the WinRT 'CoreWindow', and pass it into IDXGIFactory2::CreateSwapChainForCoreWindow() as appropriate.) What partially works: keyboard input. Most of WinRT's documented virtual keys are supported, as well as many keys with documented hardware scancodes. Converting SDL_Scancodes to or from SDL_Keycodes may not work, due to missing APIs (MapVirtualKey()) in Microsoft's Windows Store / UWP APIs. SDLmain. WinRT uses a different signature for each app's main() function. SDL-based apps that use this port must compile in SDL_winrt_main_NonXAML.cpp (in SDL\\src\\main\\winrt\\ ) directly in order for their C-style main() functions to be called. What doesn't work: compilation with anything other than Visual C++ programmatically-created custom cursors. These don't appear to be supported by WinRT. Different OS-provided cursors can, however, be created via SDL_CreateSystemCursor() (unsupported on Windows Phone) SDL_WarpMouseInWindow() or SDL_WarpMouseGlobal(). This are not currently supported by WinRT itself. joysticks and game controllers that either are not supported by Microsoft's XInput API, or are not supported within UWP apps (many controllers that work in Win32, do not work in UWP, due to restrictions in UWP itself). turning off VSync when rendering on Windows Phone. Attempts to turn VSync off on Windows Phone result either in Direct3D not drawing anything, or it forcing VSync back on. As such, SDL_RENDERER_PRESENTVSYNC will always get turned-on on Windows Phone. This limitation is not present in non-Phone WinRT (such as Windows 8.x), where turning off VSync appears to work. probably anything else that's not listed as supported","title":"Status"},{"location":"README-winrt/#upgrade-notes","text":"","title":"Upgrade Notes"},{"location":"README-winrt/#setup-high-level-steps","text":"The steps for setting up a project for an SDL/WinRT app looks like the following, at a high-level: create a new Visual C++ project using Microsoft's template for a, \"Direct3D App\". remove most of the files from the project. make your app's project directly reference SDL/WinRT's own Visual C++ project file, via use of Visual C++'s \"References\" dialog. This will setup the linker, and will copy SDL's .dll files to your app's final output. adjust your app's build settings, at minimum, telling it where to find SDL's header files. add files that contains a WinRT-appropriate main function, along with some data to make sure mouse-cursor-hiding (via SDL_ShowCursor(SDL_DISABLE) calls) work properly. add SDL-specific app code. build and run your app.","title":"Setup, High-Level Steps"},{"location":"README-winrt/#setup-detailed-steps","text":"","title":"Setup, Detailed Steps"},{"location":"README-winrt/#include","text":"int main(int argc, char **argv) { SDL_DisplayMode mode; SDL_Window * window = NULL; SDL_Renderer * renderer = NULL; SDL_Event evt; if (SDL_Init(SDL_INIT_VIDEO) != 0) { return 1; } if (SDL_GetCurrentDisplayMode(0, &mode) != 0) { return 1; } if (SDL_CreateWindowAndRenderer(mode.w, mode.h, SDL_WINDOW_FULLSCREEN, &window, &renderer) != 0) { return 1; } while (1) { while (SDL_PollEvent(&evt)) { } SDL_SetRenderDrawColor(renderer, 0, 255, 0, 255); SDL_RenderClear(renderer); SDL_RenderPresent(renderer); } }","title":"include "},{"location":"README-winrt/#troubleshooting","text":"","title":"Troubleshooting"}]}